#include "LeastSquareSolver.h"
#include <algorithm>

extern "C" {
  // LAPACK: QR factorization with column pivoting (A*P = Q*R)
  void _FORTRAN(dgeqp3)(const int* m, const int* n, double* a, const int* lda, int* jptv,
                        double* tau, double* work, const int* lwork, int* info);

  // LAPACK: Multiplication by orthogonal Q generated by DGEQP3
  void _FORTRAN(dormqr)(const char* side, const char* trans, const int* m, const int* n, const int* k,
                        const double* a, const int* lda, const double * tau, double * c, const int* ldc,
                        double* work, const int* lwork, int* info);

  // BLAS: Backward/Forward substitution
  void _FORTRAN(dtrsv)(const char* uplo, const char* trans, const char* diag, const int* n,
                       const double* a, const int* lda, double* x, const int* incx);
}

namespace Pita {

LeastSquareSolver::LeastSquareSolver(double tol) :
  RankDeficientSolver(),
  transposedMatrix_(),
  tolerance_(tol),
  tau_(), 
  workspace_()
{}

void
LeastSquareSolver::transposedMatrixIs(const FullSquareMatrix & transposedMatrix) {
  transposedMatrix_.copy(transposedMatrix);
  setMatrixSize(transposedMatrix_.dim());
  setFactorRank(0);
  setStatus(NON_FACTORIZED);
}

void
LeastSquareSolver::statusIs(LeastSquareSolver::Status s) {
  if (status() == s) {
    return;
  }

  if (s == FACTORIZED) {
    // Initialize arrays for factorization
    getFactorPermutation().sizeIs(matrixSize());
    std::fill_n(getFactorPermutation().array(), matrixSize(), 0); // All columns are free

    tau_.sizeIs(matrixSize());

    const int workspaceSize = 3 * matrixSize() + 1; // TODO optimize
    workspace_.sizeIs(workspaceSize); 

    int info;

    // Perform factorization
    _FORTRAN(dgeqp3)(&getMatrixSize(), &getMatrixSize(), transposedMatrix_.data(), &getMatrixSize(), getFactorPermutation().array(),
        tau_.array(), workspace_.array(), &workspaceSize, &info);

    // Determine numerical rank
    updateFactorRank();
  }

  setStatus(s);
}

void
LeastSquareSolver::toleranceIs(double tol) {
  if (tolerance() != tol) {
    tolerance_ = tol;
    if (status() == FACTORIZED) {
      updateFactorRank();
    }
  }
}

const Vector &
LeastSquareSolver::solution(Vector & rhs) const {
  if (this->matrixSize() != rhs.size()) {
    throw Fwk::RangeException("in LeastSquareSolver::solution - Size mismatch");
  }

  if (this->status() != FACTORIZED) {
    throw Fwk::RangeException("in LeastSquareSolver::solution - Non-factorized matrix");
  }

  // 1) rhs(1:rank) <- Q_1^T rhs
  const char side = 'L';   // Multiply on the left
  const char qTrans = 'T'; // Transpose the matrix
  const int cols = 1;      // Single rhs vector
  
  const int workspaceSize = workspace_.size(); // TODO optimize
  workspace_.sizeIs(workspaceSize);

  int info;

  _FORTRAN(dormqr)(&side, &qTrans, &getMatrixSize(), &cols, &getFactorRank(),
                   transposedMatrix_.data(), &getMatrixSize(), tau_.array(), rhs.data(), &getMatrixSize(),
                   workspace_.array(), &workspaceSize, &info); 

  // 2) rhs(1:rank) <- R_{11}^-1 rhs(1:rank)
  const char uplo = 'U';   // Upper triangular (in Fortran indexing)
  const char sTrans = 'N'; // No transpose
  const char diag = 'N';   // Non-unit diagonal
  const int incx = 1;      // Rhs vector elements are contiguous

  _FORTRAN(dtrsv)(&uplo, &sTrans, &diag, &getFactorRank(), transposedMatrix_.data(),
                  &getMatrixSize(), rhs.data(), &incx);

  // 3) rhs(perm) <- [rhs(1:rank); zeros(matrixSize - rank, 1)]
  std::copy(rhs.data(), rhs.data() + factorRank(), workspace_.array());
  rhs.zero();
  double * rhs_ptr = rhs.data() - 1; // Fortran -> C indexing
  for (int i = 0; i < factorRank(); ++i) {
    rhs_ptr[getFactorPermutation()[i]] = workspace_[i];
  }

  return rhs;
}

void
LeastSquareSolver::updateFactorRank() {
  double diagMax = abs(transposedMatrix_[0][0]);
  int fr = 0;
  while (fr < matrixSize() && abs(transposedMatrix_[fr][fr]) > tolerance_ * diagMax) {
    ++fr;
  }
  setFactorRank(fr);
}

} /* end namespace Pita */
