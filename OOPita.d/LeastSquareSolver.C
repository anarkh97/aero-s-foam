#include "LeastSquareSolver.h"

#include <algorithm>

extern "C" {
  // LAPACK: QR factorization with column pivoting (A*P = Q*R)
  void _FORTRAN(dgeqp3)(const int* m, const int* n, double* a, const int* lda, int* jptv,
                        double* tau, double* work, const int* lwork, int* info);

  // LAPACK: Multiplication by orthogonal Q generated by DGEQP3
  void _FORTRAN(dormqr)(const char* side, const char* trans, const int* m, const int* n, const int* k,
                        const double* a, const int* lda, const double * tau, double * c, const int* ldc,
                        double* work, const int* lwork, int* info);

  // BLAS: Backward/Forward substitution
  void _FORTRAN(dtrsv)(const char* uplo, const char* trans, const char* diag, const int* n,
                       const double* a, const int* lda, double* x, const int* incx);
}

namespace Pita {

LeastSquareSolver::LeastSquareSolver(double tol) :
  status_(NON_FACTORIZED),
  transposedMatrix_(),
  matrixSize_(0),
  tolerance_(tol),
  factorRank_(0),
  factorPermutation_(),
  tau_(), 
  workspace_()
{}

void
LeastSquareSolver::transposedMatrixIs(const FullSquareMatrix & transposedMatrix) {
  transposedMatrix_.copy(transposedMatrix);
  matrixSize_ = transposedMatrix_.dim();
  status_ = NON_FACTORIZED;
  // Remark: factorRank, factorPermutation not up-to-date
}

void
LeastSquareSolver::statusIs(LeastSquareSolver::Status s) {
  if (status() == s) {
    return;
  }

  if (s == FACTORIZED) {
    // Initialize arrays for factorization
    factorPermutation_.sizeIs(matrixSize());
    std::fill_n(factorPermutation_.array(), matrixSize(), 0); // All columns are free

    tau_.sizeIs(matrixSize());

    const int workspaceSize = 3 * matrixSize() + 1; // TODO optimize
    workspace_.sizeIs(workspaceSize); 

    int info;

    // Perform factorization
    _FORTRAN(dgeqp3)(&matrixSize_, &matrixSize_, transposedMatrix_.data(), &matrixSize_, factorPermutation_.array(),
        tau_.array(), workspace_.array(), &workspaceSize, &info);

    // Determine numerical rank
    updateFactorRank();
  }

  status_ = s;
}

void
LeastSquareSolver::toleranceIs(double tol) {
  if (tolerance() != tol) {
    tolerance_ = tol;
    if (status() == FACTORIZED) {
      updateFactorRank();
    }
  }
}

const Vector &
LeastSquareSolver::solution(Vector & rhs) const {
  if (this->matrixSize() != rhs.size()) {
    throw Fwk::RangeException("in LeastSquareSolver::solution - Size mismatch");
  }

  if (this->status() != FACTORIZED) {
    throw Fwk::RangeException("in LeastSquareSolver::solution - Non-factorized matrix");
  }

  // 1) rhs(1:rank) <- Q_1^T rhs
  const char side = 'L';   // Multiply on the left
  const char qTrans = 'T'; // Transpose the matrix
  const int cols = 1;      // Single rhs vector
  
  const int workspaceSize = workspace_.size(); // TODO optimize
  workspace_.sizeIs(workspaceSize);

  int info;

  _FORTRAN(dormqr)(&side, &qTrans, &matrixSize_, &cols, &factorRank_,
                   transposedMatrix_.data(), &matrixSize_, tau_.array(), rhs.data(), &matrixSize_,
                   workspace_.array(), &workspaceSize, &info); 

  // 2) rhs(1:rank) <- R_{11}^-1 rhs(1:rank)
  const char uplo = 'U';   // Upper triangular (in Fortran indexing)
  const char sTrans = 'N'; // No transpose
  const char diag = 'N';   // Non-unit diagonal
  const int incx = 1;      // Rhs vector elements are contiguous

  _FORTRAN(dtrsv)(&uplo, &sTrans, &diag, &factorRank_, transposedMatrix_.data(),
                  &matrixSize_, rhs.data(), &incx);

  // 3) rhs(perm) <- [rhs(1:rank); zeros(matrixSize - rank, 1)]
  std::copy(rhs.data(), rhs.data() + factorRank_, workspace_.array());
  rhs.zero();
  double * rhs_ptr = rhs.data() - 1; // Fortran -> C indexing
  for (int i = 0; i < factorRank_; ++i) {
    rhs_ptr[factorPermutation_[i]] = workspace_[i];
  }

  return rhs;
}

void
LeastSquareSolver::updateFactorRank() {
  double diagMax = abs(transposedMatrix_[0][0]);
  factorRank_ = 0;
  while (factorRank_ < matrixSize() && abs(transposedMatrix_[factorRank_][factorRank_]) > tolerance_ * diagMax) {
    ++factorRank_;
  }
}

} /* end namespace Pita */

