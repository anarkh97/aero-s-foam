#if defined(USE_SCALAPACK) && defined(USE_EIGEN3)
#include "DistrSnapshotClusteringSolver.h"

#include <Comm.d/Communicator.h>
#include <Math.d/SCMatrix.d/SCDoubleMatrix.h>
#include <Utils.d/linkfc.h>

#include <mpi.h>

extern "C" {
  // Context & cpu topology management
  int Csys2blacs_handle(MPI_Comm comm);

  void Cfree_blacs_system_handle(int handle);
  void Cblacs_gridinit(int *ictxt, char *order, int nprow, int npcol);

  void Cblacs_gridinfo(int ictxt, int *nprow, int *npcol, int *myrow, int *mycol);
  void Cblacs_gridexit(int ictxt);

  // Index mapping 
  int _FORTRAN(indxg2l)(const int *indxglob, const int *nb, const int *iproc_dummy, const int *isrcproc_dummy, const int *nprocs);
  int _FORTRAN(indxg2p)(const int *indxglob, const int *nb, const int *iproc_dummy, const int *isrcproc, const int *nprocs);
}

namespace Rom {

DistrSnapshotClusteringSolver
::DistrSnapshotClusteringSolver(Communicator * comm, int rowCount, int colCount, int localRows, int numClusters,
                                int blockSize) : 
  communicator_(comm),
  rowCount_(rowCount),
  colCount_(colCount),
  localRows_(localRows),
  numClusters_(numClusters),
  blockSize_(blockSize),
  matrixBuffer_(localRows,colCount),
  clusterBuffer_(numClusters)
{
}

void
DistrSnapshotClusteringSolver::solve()
{
  // 1. Construct matrix A
  int blacsHandle = Csys2blacs_handle(*communicator_->getCommunicator());
  int context = blacsHandle;
  char order[] = "R";
  int rowCpus = communicator_->numCPUs();
  int colCpus = 1;
  Cblacs_gridinit(&context, order, rowCpus, colCpus);
  SCDoubleMatrix A(context, rowCount_, colCount_, blockSize_, blockSize_, *communicator_->getCommunicator());

  // 2. Copy rows and columns from matrixBuffer into A
  int myrow, mycol;
  int dummy, zero=0;
  Cblacs_gridinfo(context, &rowCpus, &colCpus, &myrow, &mycol);
  double *row = new double[colCount_];
  for(int j=1; j<=rowCount_; j++) {
    int p = _FORTRAN(indxg2p)(&j, &blockSize_, &dummy, &zero, &rowCpus);
    if(myrow == p) {
      int lj = _FORTRAN(indxg2l)(&j, &blockSize_, NULL, NULL, &rowCpus) - 1;
      for(int k=0; k<colCount_; ++k) row[k] = -matrixBuffer_(lj,k);
      A.setMatrixRow(j, row);
    }
  }

  std::vector<int> clusterAssignment(colCount_);

  // TODO: replace this random assigment with k-means solution
  for(int k=0; k<colCount_; ++k) clusterAssignment[k] = rand()%numClusters_;

  std::vector<int> count(numClusters_, 0);
  for(int k=0; k<colCount_; ++k) {
    int i = clusterAssignment[k];
    count[i]++;
  }
  for(int i = 0; i < numClusters_; ++i) {
    if(communicator_->myID() == 0) {
      std::cerr << "Cluster # " << i << " has " << count[i] << " snapshots assigned to it\n";
    }
    clusterBuffer_[i].resize(localRows_,count[i]);
  }

  // copy solution into clusterBuffer_
  for(int j=1; j<=rowCount_; j++) {
    int p = _FORTRAN(indxg2p)(&j, &blockSize_, &dummy, &zero, &rowCpus);
    if(myrow == p) {
      int lj = _FORTRAN(indxg2l)(&j, &blockSize_, NULL, NULL, &rowCpus) - 1;
      A.getMatrixRow(j, row, 'U');
      std::vector<int> count(numClusters_, 0);
      for(int k=0; k<colCount_; ++k) {
        int i = clusterAssignment[k];
        clusterBuffer_[i](lj,count[i]++) = row[k];
      }
    }
  }  

  delete [] row;

  Cblacs_gridexit(context);
  Cfree_blacs_system_handle(blacsHandle);
}

} // end namespace Rom
#endif
