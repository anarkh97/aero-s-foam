#if defined(USE_SCALAPACK) && defined(USE_EIGEN3)
#include "DistrSnapshotClusteringSolver.h"

#include <Comm.d/Communicator.h>
#include <Math.d/SCMatrix.d/SCDoubleMatrix.h>
#include <Utils.d/linkfc.h>

#include <mpi.h>

extern "C" {
  // Context & cpu topology management
  int Csys2blacs_handle(MPI_Comm comm);

  void Cfree_blacs_system_handle(int handle);
  void Cblacs_gridinit(int *ictxt, char *order, int nprow, int npcol);

  void Cblacs_gridinfo(int ictxt, int *nprow, int *npcol, int *myrow, int *mycol);
  void Cblacs_gridexit(int ictxt);

  // Index mapping 
  int _FORTRAN(indxg2l)(const int *indxglob, const int *nb, const int *iproc_dummy, const int *isrcproc_dummy, const int *nprocs);
  int _FORTRAN(indxg2p)(const int *indxglob, const int *nb, const int *iproc_dummy, const int *isrcproc, const int *nprocs);
}

namespace Rom {

DistrSnapshotClusteringSolver
::DistrSnapshotClusteringSolver(Communicator * comm, int rowCount, int colCount, int localRows, int numClusters,
                                int blockSize) : 
  communicator_(comm),
  rowCount_(rowCount),
  colCount_(colCount),
  localRows_(localRows),
  numClusters_(numClusters),
  blockSize_(blockSize),
  matrixBuffer_(localRows,colCount),
  clusterCols_(numClusters)
{
}

void
DistrSnapshotClusteringSolver::solve()
{
  // block-cyclic redistribution of snapshot matrix
  int *localRows = new int[communicator_->numCPUs()];
  for(int i=0; i<communicator_->numCPUs(); ++i) localRows[i] = (i == communicator_->myID()) ? localRows_ : 0;
  communicator_->globalSum(communicator_->numCPUs(), localRows);

  int blacsHandle = Csys2blacs_handle(*communicator_->getCommunicator());
  int context = blacsHandle;
  char order[] = "R";
  int rowCpus = communicator_->numCPUs();
  int colCpus = 1;
  Cblacs_gridinit(&context, order, rowCpus, colCpus);
  SCDoubleMatrix X(context, rowCount_, colCount_, blockSize_, blockSize_, *communicator_->getCommunicator());

  int myrow, mycol;
  int dummy, zero=0;
  Cblacs_gridinfo(context, &rowCpus, &colCpus, &myrow, &mycol);

  int localBlacsHandle = Csys2blacs_handle(MPI_COMM_SELF);
  int localContext = localBlacsHandle;
  Cblacs_gridinit(&localContext, order, 1, 1);
/*
  for(int i=0; i<communicator_->numCPUs(); ++i) { if(i == communicator_->myID()) {
    std::cerr << "myID = " << communicator_->myID() << ", firstRow = " << firstRow << ", localRows_ = " << localRows_ << ", rowCount_ = " << rowCount_ << std::endl;
  } communicator_->sync(); }

  // redistribute matrix 1 row at a time
  SCDoubleMatrix Xi(localContext, 1, colCount_, blockSize_, blockSize_, MPI_COMM_SELF);
  double *row = new double[colCount_];
  int firstRow = 1;
  for(int i=0; i<communicator_->myID(); ++i) firstRow += localRows[i];
  for(int i=1; i<=rowCount_; i++) {
    if((i >= firstRow) && (i < firstRow+localRows_)) {
      int li = i-firstRow;
      for(int k=0; k<colCount_; ++k) row[k] = matrixBuffer_(li,k);
      Xi.setMatrixRow(1, row);
      Xi.copyRedist(1, colCount_, 1, 1, X, i, 1, context); 
    }
    else {
      SCDoubleMatrix::copyRedist(1, colCount_, X, i, 1, context);
    }
  }
  delete [] row;
*/
  SCDoubleMatrix Xi(localContext, localRows_, colCount_, blockSize_, blockSize_, MPI_COMM_SELF);
  for(int i=0,ia=1; i<communicator_->numCPUs(); i++) {
    if(i == communicator_->myID()) {
      for(int k=0; k<colCount_; ++k){
        Xi.setMatrixColumn(k+1, matrixColBuffer(k));
      }
      std::cerr << "Xi.froNorm() = " << Xi.froNorm()  << std::endl;
      Xi.copyRedist(localRows_, colCount_, 1, 1, X, ia, 1, context); 
    }
    else {
      SCDoubleMatrix::copyRedist(localRows[i], colCount_, X, ia, 1, context);
    }
    ia+=localRows[i];
  }
  delete [] localRows;

  double Xnorm = X.froNorm();
  
  for(int i=0; i<communicator_->numCPUs(); ++i) { if(i == communicator_->myID()) {
  std::cerr << "matrixBuffer_.norm() = " << matrixBuffer_.norm() << std::endl;
  std::cerr << "X.froNorm() = " << Xnorm << std::endl;
  } communicator_->sync(); }

  Cblacs_gridexit(localContext);
  Cfree_blacs_system_handle(localBlacsHandle);

  // TODO: replace this random assigment with k-means solution
  std::vector<int> clusterAssignment(colCount_);
  for(int k=0; k<colCount_; ++k) clusterAssignment[k] = rand()%numClusters_;

  // make a list of the columns assigned to each cluster
  for(int k=0; k<colCount_; ++k) {
    int i = clusterAssignment[k];
    clusterCols_[i].push_back(k);
  }

  Cblacs_gridexit(context);
  Cfree_blacs_system_handle(blacsHandle);
}

} // end namespace Rom
#endif
