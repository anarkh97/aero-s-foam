#ifdef STRUCTOPT

#include <cstdlib>
#include <cstdio>

#include <Structopt.d/Optinp.h>
#include <Structopt.d/Optpro.h>
#include <Structopt.d/Optsol.h>
#include <Structopt.d/Optobj.h>
#include <Structopt.d/Optcon.h>
#include <Structopt.d/Optopr.h>

#include <Structopt.d/Structopt_sd.h>

//------------------------------------------------------------------------------

void Optpro::inputcheck() {

    int error = 0;
  
    int i;
    for ( i=0;i<numcrit;i++ ) {
       if ( ! opc[i] ) {
         fprintf(stderr,"Input error: %d. criteria not defined\n",i+1);
         error++;
       }
    }

    // objective only required for optimization problems

    if (type==0) {
    
      if ( ! optobj->multicrit ) {
        fprintf(stderr,"Input error: objective not defined\n");
        error++;
      }
    }
    
    for ( i=0;i<optcon->numcon;i++ ) {
       if ( ! optcon->opr[i] ) {
         fprintf(stderr,"Input error: %d. constraint not defined\n",i+1);
         error++;
       }
    }
       
    for ( i=0;i<optvar->nAbs();i++ ) {
      if ( ! optvar->getAbsVar(i) ) {
          fprintf(stderr,"Input error: %d. abs.var. not defined\n",i+1);
         error++;
       }
    }
      
    for ( i=0;i<optvar->nStc();i++ ) {
      if ( ! optvar->getStcVar(i) ) {
          fprintf(stderr,"Input error: %d. stc.var. not defined\n",i+1);
         error++;
       }
    }
       
    if ( error ) {
      fprintf(stderr,"%d errors detected in optimization input. Aborting\n",
              error);
      exit(-1);
    }

    int typ1=optvar->getAbsVar(0)->gettype();
    for ( i=1;i<optvar->nAbs();i++ ) {
      if ( optvar->getAbsVar(i)->gettype() != typ1 ) {
	fprintf(stderr,
		"Input error: type of %d. absvar is different from type of absvar %d\n",i+1,1);
	error++;
       }
    }

    if ( error ) {
      fprintf(stderr,"%d errors detected in optimization input. Aborting\n",
              error);
      exit(-1);
    }

}       

//------------------------------------------------------------------------------

void Optpro::addCriteria( criterion & crit )
{
  int num=crit.num-1;

  if ( opc[num] ) {
    fprintf(stderr,
            "Error generating criteria: %d. criteria already defined\n",
            crit.num);
      exit(-1);
  }

  opc[num]=Optcrit::build(crit.num,crit.data,crit.t,crit.anaId);

  if ( numcrit < crit.num ) numcrit = crit.num;

  if ( crit.igen ) {
  
    if ( ! opc[crit.gena] ) { 
      fprintf(stderr,
              "Error generating criteria: %d. criteria does not exists\n",
              crit.gena+1);
      exit(-1);
    }

    if ( ! opc[crit.genb] ) { 
      fprintf(stderr,
              "Error generating criteria: %d. criteria does not exists\n",
              crit.genb+1);
      exit(-1);
    }
  
    int typa = opc[crit.gena]->gettyp();
    int typb = opc[crit.genb]->gettyp();

    if ( ! typa == typb ) {
      fprintf(stderr,
      "Error generating criteria: criteria %d and %d are not of same type \n",
      crit.gena+1,crit.genb+1);
      exit(-1);
    }

    if ( typa == 13 && typb == 14 ) {
      fprintf(stderr,
      "Error generating criteria: criteria %d can not be generated by GEN \n",
      crit.gena+1);
      exit(-1);
    }

    double refa = opc[crit.gena]->getRef();
    double powa = opc[crit.gena]->getPow();

    double refb = opc[crit.genb]->getRef();
    double powb = opc[crit.genb]->getPow();

    if ( ! refa == refb ) {
      fprintf(stderr,
      "Error generating criteria: criteria %d and %d have different reference stresses\n",
      crit.gena+1,crit.genb+1);
      exit(-1);
    }

    if ( ! powa == powb ) {
      fprintf(stderr,
      "Error generating criteria: criteria %d and %d have different exponents for stress\n",
      crit.gena+1,crit.genb+1);
      exit(-1);
    }

    int gnum = crit.genb - crit.gena;

    int i1a = opc[crit.gena]->getloc1();
    int i1b = opc[crit.genb]->getloc1();
    int di1 = (i1b - i1a) / gnum;
    
    int i2a = opc[crit.gena]->getloc2();
    int i2b = opc[crit.genb]->getloc2();
    int di2 = (i2b - i2a) / gnum;
    
    double ta = opc[crit.gena]->getTime();
    double tb = opc[crit.genb]->getTime();
    double dt = (tb - ta) / static_cast<double>(gnum);

    if ( (ta*tb) < 0 ) {
      fprintf(stderr,
      "Error generating criteria: time of criteria %d or %d is not set\n",
      crit.gena+1,crit.genb+1);
      exit(-1);
    }

    int anaIda = opc[crit.gena]->getAnalysisId();
    int anaIdb = opc[crit.genb]->getAnalysisId();

    if (anaIda != anaIdb) {
      fprintf(stderr,
      "Error generating criteria: Analysis Ids of of criteria %d or %d differ.\n",
      crit.gena+1,crit.genb+1);
      exit(-1);
    }

    int newnum;
    critdata ncdata;

    ncdata.i[0]=i1a;
    ncdata.i[1]=i2a;
    ncdata.d[0]=refa;
    ncdata.d[1]=powa;

    for (newnum=crit.gena+1;newnum<crit.genb;newnum+=crit.gens) {
      num   = newnum+1;
      ncdata.i[0]  += di1;
      ncdata.i[1]  += di2;    
      ta   += dt;
      if ( opc[newnum] ) {
        fprintf(stderr,
	        "Error generating criteria: %d. criteria already defined\n",
                num);
        exit(-1);
      }
      opc[newnum]=Optcrit::build(num,ncdata,ta,anaIda);      
    }

  }
 
  // cleanup criterion

  crit.cleanup();
}

//------------------------------------------------------------------------------

void Optpro::addObjective( double scal,  funcall & func )
{
  optobj->scalobj = scal;                                    
  
  optobj->multicrit = addFunc(func);
}  

//------------------------------------------------------------------------------

void Optpro::addObjective( double scal,  Optopr* objopr )
{
  optobj->scalobj   = scal;                                    
  
  optobj->multicrit = objopr;
}  

//------------------------------------------------------------------------------
      
void Optpro::addConstraint( int num, int typ, double scl, funcall & func )
{
  int inum = num-1;

  if ( optcon->opr[inum] ) {
    fprintf(stderr,
            "Error generating constraint: %d. constraint already defined\n",
            num);
    exit(-1);
  }
    
  if ( optcon->numcon < num ) optcon->numcon = num ;
  
  optcon->typcon[inum]  = typ;
  optcon->scalcon[inum] = scl;
  
  optcon->opr[inum] = addFunc(func);
  
  if ( typ )
    optcon->numieq++;
  else
    optcon->numeqc++;
}

//------------------------------------------------------------------------------

void Optpro::addDsgvar( absvardata & var )
{
  int num=var.num-1;

  optvar->addAbsVar(num, Absvar::create(0,var)); 

  if ( var.igen ) {
  
    if ( ! optvar->getAbsVar(var.gena) ) { 
      fprintf(stderr,"Error generating abs.var.: %d variable does not exists\n",
              var.gena+1);
      exit(-1);
    }

    if ( ! optvar->getAbsVar(var.genb) ) { 
      fprintf(stderr,"Error generating abs.var.: %d variable does not exists\n",
              var.genb+1);
      exit(-1);
    }
  
    double gnum = static_cast<double>(var.genb - var.gena);

    double vala  = optvar->getAbsVar(var.gena)->getval();
    double valb  = optvar->getAbsVar(var.genb)->getval();
    double dval  = (valb - vala) / gnum;
    
    double scla  = optvar->getAbsVar(var.gena)->getscal();
    double sclb  = optvar->getAbsVar(var.genb)->getscal();
    double dscl  = (sclb - scla) / gnum;

    double lowa  = optvar->getAbsVar(var.gena)->getlow();
    double lowb  = optvar->getAbsVar(var.genb)->getlow();
    double dlow  = (lowb - lowa) / gnum;

    double uppa  = optvar->getAbsVar(var.gena)->getupp();
    double uppb  = optvar->getAbsVar(var.genb)->getupp();
    double dupp  = (uppb - uppa) / gnum;
    
    double vina  = optvar->getAbsVar(var.gena)->getnewval();
    double vinb  = optvar->getAbsVar(var.genb)->getnewval();
    double dvin  = (vinb - vina) / gnum;

    int newnum;
    absvardata gvar;

    for (newnum=var.gena+1;newnum<var.genb;newnum+=var.gens) {

       num   = newnum+1;
       vala += dval;
       scla += dscl;
       lowa += dlow;
       uppa += dupp;  
       vina += dvin;
  
       if ( optvar->getAbsVar(newnum) ) {
         fprintf(stderr,
	         "Error generating abs.var.: %d. variable already defined\n",
                 num);
         exit(-1);
       }              
     
       gvar.num = num;
       gvar.val = vala;
       gvar.scl = scla;
       gvar.low = lowa;
       gvar.upp = uppa;
       gvar.vin = vina;

       optvar->addAbsVar(newnum, Absvar::create(0,gvar));
    }
  }
}

//------------------------------------------------------------------------------

void Optpro::addStcvar( int num, int typ, int loc1, int loc2,
                        funcall & func, int rfg )
{
  optvar->addStcVar(num-1, Stcvar::build(num,typ,loc1,loc2,rfg));
  optvar->addOpr(num-1, addFunc(func));
  
  //build abs-stc variable table
  optvar->buildAStable(num-1);

  // count the number of thermal and electrostatic attribute stcvar

  switch (typ) {
    case Optvar::elecattr:
      numElecStcVar++;
      break;
    case Optvar::thermattr:
      numThermStcVar++;
      break;
  }

 } 


//------------------------------------------------------------------------------

void Optsol::addSolver( int & num, int & typ, nlpdata & param, graddata & grad )
{
    optalg[numalg]=Optalg::create(num,typ);
  
    optalg[numalg]->buildalg(param);

    optalg[numalg]->getOptgrad()->buildgrad(grad);

    if (grad.numFilCrit) delete [] grad.filcritList;
    if (grad.numGroups)  delete [] grad.filGrpsList;

    numalg++;                                  
}

//------------------------------------------------------------------------------

Optopr * Optpro::addFunc( funcall & func)
{
  Optopr *opr = Optopr::create(func.typ);
  
  int iopr;
  
  if (func.fdata->numopr > MAXOPR) {
    fprintf(stderr,"**** ERROR: MAXOPR exceeded ... stop\n");
    exit(-1);
  }

  for (iopr=0;iopr<func.fdata->numopr;iopr++) {

     int cnum,onum,vnum;
     double a,p,b;
     Optopr * newopr;
     
     switch (func.fdata->oprtyp[iopr]) {
     
     case 0:
       cnum = func.fdata->oprnum[iopr];
       if (cnum < 0 || cnum >= numcrit) {
	 fprintf(stderr,
	 " Error building function: void criterion in entry %d\n",iopr+1);
         exit(-1);
       }
       a    = func.fdata->a[iopr];
       p    = func.fdata->p[iopr];
       b    = func.fdata->b[iopr];	
       if ( opc[cnum] ) {
	 opr->build(opc[cnum],a,p,b);
       } 
       else {
	 fprintf(stderr,
	 " Error building function: Criterion[%d] does not exists\n",cnum+1);
         exit(-1);
       }
       break;
      
     case 1:
       onum = func.fdata->oprnum[iopr];
       if (onum < 0 || onum >= func.fdata->numopr) {
	 fprintf(stderr,
	 " Error building function: void function in entry %d\n",iopr+1);
         exit(-1);
       }
       a    = func.fdata->a[iopr];
       p    = func.fdata->p[iopr];
       b    = func.fdata->b[iopr];	
       newopr = addFunc(func.fdata->subfunc[onum]); 
       opr->build(newopr,a,p,b);
       break;
	
     case 2:
       vnum = func.fdata->oprnum[iopr];
       if (vnum < 0 || vnum > optvar->nAbs()) {
	 fprintf(stderr,
	 " Error building function: void variable in entry %d\n",iopr+1);
         exit(-1);
       }
       a    = func.fdata->a[iopr];
       p    = func.fdata->p[iopr];
       b    = func.fdata->b[iopr];	
       if ( optvar->getAbsVar(vnum) ) {
         opr->build(optvar->getAbsVar(vnum),a,p,b);
       } 
       else {
	 fprintf(stderr,
	 "Error building function: Abs. Var.[%d] does not exists\n",cnum+1);
         exit(-1);
       }
       break;
     }
  }      
	
  int igen;	
	
  for (igen=0;igen<func.fdata->numgen;igen++) {

    int gena = func.fdata->gena[igen];
    int genb = func.fdata->genb[igen];
    int gens = func.fdata->gens[igen];
    
    int numa=-1;
    int numb=-1;
    
    int i;
    for (i=0;i<func.fdata->numopr;i++) {
       if ( func.fdata->numstat[i] == gena ) numa=i;
       if ( func.fdata->numstat[i] == genb ) numb=i;
    }
    
    if ( numa == -1 ) {
      fprintf(stderr,
      "Error generating function: %d. Summand not defined.\n", 
      gena+1);
      exit(-1);
    }

    if ( numb == -1 ) {
      fprintf(stderr,
      "Error generating function: %d. Summand not defined.\n", 
      gena+1);
      exit(-1);
    }   

    int typa = func.fdata->oprtyp[numa];
    int typb = func.fdata->oprtyp[numb];
    
    if ( ! typa == typb ) {
      fprintf(stderr,
      "Error generating function: Operator %d and %d are not of same type\n", 
      gena+1,genb+1);
      exit(-1);
    }

    if ( typa == 1 ) {
      fprintf(stderr,
      "Error generating function: Generating operators not possible\n");
      exit(-1);
    }
    
    int    inum = genb - gena;
    double gnum = static_cast<double>(inum);
    
    int    na = func.fdata->oprnum[numa];
    int    nb = func.fdata->oprnum[numb];
    int    dn = (nb - na) / inum;

    double aa = func.fdata->a[numa];
    double ab = func.fdata->a[numb];
    double da = (ab - aa) / gnum;
    
    double pa = func.fdata->p[numa];
    double pb = func.fdata->p[numb];
    double dp = (pb - pa) / gnum;

    double ba = func.fdata->b[numa];
    double bb = func.fdata->b[numb];
    double db = (bb - ba) / gnum;

    int newnum;
    for (newnum=gena+1;newnum<genb;newnum+=gens) {
       na += dn;
       aa += da;
       pa += dp;
       ba += db;
       switch (typa) {
         case 0:
           if ( opc[na] ) {
	     opr->build(opc[na],aa,pa,ba);
           } 
           else {
	     fprintf(stderr,
	     " Error generating function: Criteria[%d] does not exists\n",na+1);
             exit(-1);
           }
           break;
         case 2:
           if ( optvar->getAbsVar(na) ) {
	     opr->build(optvar->getAbsVar(na),aa,pa,ba);
           } 
           else {
	     fprintf(stderr,
	     "Error building function: Abs. Var.[%d] does not exists\n",na+1);
             exit(-1);
           }
           break;
       }
    }
  }

  // delete funcall structure and sub-structures

  cleanFuncall(func);

  return opr;
}        
		  
//------------------------------------------------------------------------------
// external functions
//------------------------------------------------------------------------------

void initFuncall(funcall & fc)
{ 
  fc.typ   = -99;
  fc.fdata =   0;
}

//------------------------------------------------------------------------------

void cleanFuncall(funcall &fc)
{ 
  if (fc.typ != -99) {
    cleanFuncdata(*(fc.fdata));
    //delete [] fc.fdata;
  }

  fc.typ   = -99;
  fc.fdata =   0;
}

//------------------------------------------------------------------------------

funcdata * buildFuncdata() 
{
  funcdata * fd = new funcdata;
   
  fd->numstat = new int[MAXOPR];
  fd->oprtyp  = new int[MAXOPR];
  fd->oprnum  = new int[MAXOPR];
  fd->gena    = new int[MAXOPR];
  fd->genb    = new int[MAXOPR];
  fd->gens    = new int[MAXOPR];
  fd->a	      = new double[MAXOPR];
  fd->p	      = new double[MAXOPR];
  fd->b	      = new double[MAXOPR];
  fd->subfunc = new funcall[MAXOPR];
  
  int i;
  for(i=0;i<MAXOPR;i++) initFuncall(fd->subfunc[i]);
  
  return fd;
}

//------------------------------------------------------------------------------
    
void cleanFuncdata(funcdata &fd) 
{ 
  int i;
  for(i=0;i<MAXOPR;i++) 
    cleanFuncall(fd.subfunc[i]);

  delete [] fd.numstat; 
  delete [] fd.oprtyp;  
  delete [] fd.oprnum;
  delete [] fd.gena;    
  delete [] fd.genb;	
  delete [] fd.gens;
  delete [] fd.a;       
  delete [] fd.p;	
  delete [] fd.b;
  delete [] fd.subfunc;

  fd.numstat = 0;
  fd.oprtyp = 0; 
  fd.oprnum = 0;
  fd.gena = 0;   
  fd.genb = 0;
  fd.gens = 0;
  fd.a = 0;	   
  fd.p = 0;
  fd.b = 0;
  fd.subfunc = 0;
  
}

#endif
