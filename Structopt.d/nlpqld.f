      SUBROUTINE NLPQL (IALG,
     1                  X,XL,XU,F,G,DF,DG,
     2                  N,M,ME,
     3                  U,C,D,WA,KWA,ACTIVE,
     4                  MMAX,NMAX,MNN2,LWA,LKWA,LACTIV,
     5                  ACC,SCBOU,MAXFUN,MAXIT,IPRINT,MODE,IFAIL,
     6                  LMERIT,LQL,FNAME,IFNSIZE,IOUT)
C***********************************************************************
C
C                 INTERFACE FOR NLPQLD - ALGORITHM
C
C                   CALLED BY OptalgNlpql.solve()
C
C                                                  Kurt Maute 9/11/98
C
C***********************************************************************
      IMPLICIT REAL*8 (A-H,O-Z)
C
      CHARACTER FNAME*(*),CDUM*1
C
      LOGICAL LQL,LMERIT,ACTIVE
C
      COMMON /CMACHE/EPSC
C
      EPSC=1.0D-12
C
      OPEN (IOUT,FILE=FNAME(1:IFNSIZE))
    1 READ (IOUT,1000,END=2) CDUM
      GOTO 1
    2 CONTINUE
C  
      CALL NLPQL1(X,XL,XU,F,G,DF,DG,                        
     1            U,C,D,WA,KWA,ACTIVE,
     2            M,ME,N,
     2            MMAX,NMAX,MNN2,LWA,LKWA,LACTIV,
     3            ACC,SCBOU,MAXFUN,MAXIT,IPRINT,MODE,IOUT,IFAIL,
     4            LMERIT,LQL,IALG)
C
      CLOSE (IOUT)
C      
 1000 FORMAT(A1) 
C
      RETURN
      END

C***********************************************************************
      SUBROUTINE NLPQL1(X,XL,XU,F,G,DF,DG,  
     1           U,C,D,WA,KWA,ACTIVE,           
     2           M,ME,N,
     2           MMAX,NMAX,MNN2,LWA,LKWA,LACTIV,
     3           ACC,SCBOU,MAXFUN,MAXIT,IPRINT,MODE,IOUT,IFAIL,
     4           LMERIT,LQL,IALG)
C
C
C***********************************************************************
C
C
C         AN IMPLEMENTATION OF A SEQUENTIAL QUADRATIC PROGRAMMING
C           METHOD FOR SOLVING NONLINEAR OPTIMIZATION PROBLEMS
C
C
C
C   THIS SUBROUTINE SOLVES THE GENERAL NONLINEAR PROGRAMMING PROBLEM
C
C             MINIMIZE    F(X)
C             SUBJECT TO  G(J,X)   =  0  ,  J=1,...,ME
C                         G(J,X)  >=  0  ,  J=ME+1,...,M
C                         XL  <=  X  <=  XU
C
C   THE ALGORITHM IS A MODIFICATION OF THE METHOD OF WILSON, HAN, AND
C   POWELL. IN EACH ITERATION STEP, A LINEARLY CONSTRAINED QUADRATIC
C   OR LINEAR LEAST SQUARES SUBPROBLEM IS FORMULATED BY APPROXIMATING THE
C   LAGRANGE FUNCTION QUADRATICALLY AND BY LINEARIZING THE CONSTRAINTS.
C   SUBSEQUENTLY, A ONE-DIMENSIONAL LINE SEARCH IS PERFORMED WITH
C   RESPECT TO AN AUGMENTED LAGRANGE OR AN L1 MERIT FUNCTION TO OBTAIN 
C   THE NEW ITERATE.
C
C   THE SUBROUTINE CONTAINS THE OPTIONS TO PREDETERMINE INITIAL
C   GUESSES FOR THE MULTIPLIERS OR THE HESSIAN OF THE LAGRANGE
C   FUNCTION AND TO PERFORM REVERSE COMMUNICATION. IT IS FURTHER-
C   MORE POSSIBLE TO EXCHANGE PROGRAM MODULES SUCH AS THE QUADRATIC
C   OR LINEAR LEAST SQUARES ALGORITHM, THE ONE-DIMENSIONAL MINIMI-
C   ZATION PROCEDURE, AND THE LINE-SEARCH OR MERIT FUNCTION. 
C
C
C   USAGE:
C
C      NLPQL1(M,ME,MMAX,N,NMAX,MNN2,X,F,G,DF,DG,U,XL,XU,C,D,ACC,
C             SCBOU,MAXFUN,MAXIT,IPRINT,MODE,IOUT,IFAIL,WA,LWA,KWA,LKWA,
C             ACTIVE,LACTIV,LMERIT,LQL)
C
C
C   DEFINITION OF THE PARAMETERS:
C
C   M :       NUMBER OF CONSTRAINTS.
C   ME :      NUMBER OF EQUALITY CONSTRAINTS.
C   MMAX :    ROW DIMENSION OF DG. MMAX MUST BE AT LEAST ONE AND
C             GREATER OR EQUAL TO M.
C   N :       NUMBER OF VARIABLES.
C   NMAX :    ROW DIMENSION OF C. NMAX MUST BE AT LEAST TWO AND GREATER
C             THAN N.
C   MNN2 :    MUST BE EQUAL TO M + N + N + 2.
C   X(N) :    ON INPUT, THE ONE-DIMENSIONAL ARRAY X HAS TO CONTAIN AN
C             INITIAL GUESS FOR THE OPTIMAL SOLUTION. ON RETURN, X IS
C             REPLACED BY THE LAST COMPUTED ITERATE.
C   F :       ON RETURN, F CONTAINS THE OBJECTIVE FUNCTION VALUE OF X.
C   G(MMAX) : ON RETURN, THE ARRAY G CONTAINS THE CONSTRAINT FUNCTION
C             VALUES FOR THE LAST ITERATE X.
C   DF(NMAX) : ON RETURN, DF CONTAINS THE LAST COMPUTED GRADIENT OF THE
C             OBJECTIVE FUNCTION.
C   DG(MMAX,NMAX) : ON RETURN, DG CONTAINS THE GRADIENTS OF THE ACTIVE
C             CONSTRAINTS (ACTIVE(J) = .TRUE.) OF THE LAST COMPUTED
C             ITERATE. THE REMAINING ROWS ARE FILLED WITH PREVIOUSLY
C             COMPUTED GRADIENTS. IN THE DRIVING PROGRAM, THE ROW
C             DIMENSION OF DG HAS TO BE EQUAL TO MMAX.
C   U(MNN2) : ON RETURN, U CONTAINS THE MULTIPLIERS WITH RESPECT TO THE
C             LAST COMPUTED ITERATE. THE FIRST M LOCATIONS CONTAIN THE
C             MULTIPLIERS OF THE M NONLINEAR CONSTRAINTS, THE SUBSEQUENT
C             N LOCATIONS THE MULTIPLIERS OF THE LOWER BOUNDS, AND THE
C             FOLLOWING N LOCATIONS THE MULTIPLIERS OF THE UPPER BOUNDS.
C             AT AN OPTIMAL SOLUTION, ALL MULTIPLIERS WITH RESPECT TO
C             INEQUALITY CONSTRAINTS SHOULD BE NONNEGATIVE.
C   XL(N),XU(N) : ON INPUT, THE ONE-DIMENSIONAL ARRAYS XL AND XU MUST
C             CONTAIN THE UPPER AND LOWER BOUNDS OF THE VARIABLES.
C   C(NMAX,NMAX),D(NMAX) : ON RETURN, C CONTAINS THE LAST COMPUTED
C             APPROXIMATION OF THE HESSIAN MATRIX OF THE LAGRANGE
C             FUNCTION. IF LINEAR LEAST SQUARES SUBPROBLEMS ARE FORMU-
C             LATED, C CONTAINS THE LOWER TRIANGULAR FACTOR OF AN LDL-
C             FACTORIZATION OF THE APPROXIMATION OF THE HESSIAN MATRIX
C             (WITHOUT DIAGONAL ELEMENTS, WHICH ARE ALWAYS ONE), AND
C             THE ELEMENTS OF THE DIAGONAL MATRIX ARE STORED IN THE ONE-
C             DIMENSIONAL ARRAY D. IN THE DRIVING PROGRAM, THE ROW
C             DIMENSION OF C HAS TO BE EQUAL TO NMAX.
C   ACC :     THE USER HAS TO SPECIFY THE DESIRED FINAL ACCURACY
C             (E.G. E-7).
C   SCBOU :   THE REAL VARIABLE ALLOWS AN AUTOMATIC SCALING OF THE
C             PROBLEM FUNCTIONS. IF AT THE STARTING POINT X, A FUNCTION
C             VALUE IS GREATER THAN SCBOU (E.G. E+3), THEN THIS FUNCTION
C             IS DIVIDED BY THE SQUARE ROOT. IF SCBOU IS
C             SET TO ANY NEGATIVE REAL NUMBER, THEN THE OBJECTIVE
C             FUNCTION WILL BE MULTIPLIED BY THE VALUE STORED IN
C             WA(MMAX+1) AND THE J-TH CONSTRAINT FUNCTION BY THE VALUE
C             STORED IN WA(J), J=1,...,M. NOTE THAT WHEN LEAVING NLPQL1,
C             ONLY THE FUNCTION VALUES IN F AND G, RESPECTIVELY, ARE
C             RESCALED, NOT THE DERIVATIVE VALUES IN DF AND DG.
C   MAXFUN :  THE INTEGER VARIABLE ALLOWS TO GIVE AN UPPER BOUND FOR
C             THE NUMBER OF FUNC-CALLS DURING THE LINE SEARCH (E.G. 10).
C   MAXIT :   THE USER HAS TO SPECIFY AN UPPER BOUND FOR THE NUMBER OF
C             ITERATIONS (E.G. 40).
C   IPRINT :  SPECIFICATION OF THE DESIRED OUTPUT LEVEL.
C      IPRINT = 0 :  NO OUTPUT OF THE PROGRAM.
C      IPRINT = 1 :  ONLY A FINAL CONVERGENCE ANALYSIS IS GIVEN.
C      IPRINT = 2 :  ONE LINE OF INTERMEDIATE RESULTS IS PRINTED IN EACH
C                    ITERATION.
C      IPRINT = 3 :  MORE DETAILED INFORMATION IS PRINTED IN EACH ITERATION
C                    STEP, E.G. VARIABLE, CONSTRAINT AND MULTIPLIER VALUES.
C      IPRINT = 4 :  IN ADDITION TO 'IPRINT=3', MERIT FUNCTION AND STEPLENGTH
C                    VALUES ARE DISPLAYED DURING THE LINE-SEARCH.
C   MODE :    THE INTEGER VARIABLE SPECIFIES THE DESIRED VERSION OF
C             NLPQL1.
C      MODE = 0 :    NORMAL EXECUTION.
C      MODE = 1 :    THE USER WANTS TO PROVIDE AN INITIAL GUESS FOR THE
C                    MULTIPLIERS IN U AND FOR THE HESSIAN OF THE LAGRANGE
C                    FUNCTION IN C.
C      MODE = 2 :    THE USER WANTS TO PERFORM REVERSE COMMUNICATION.
C                    IN THIS CASE, IFAIL MUST BE SET TO ZERO INITIALLY
C                    AND F, G, DF, DG HAVE TO CONTAIN THE CORRESPONDING
C                    FUNCTION AND GRADIENT VALUES. IF NLPQL1 RETURNS TO
C                    THE MAIN PROGRAM WITH  IFAIL = -1 , THE USER HAS TO
C                    CALCULATE NEW OBJECTIVE AND CONSTRAINT FUNCTION
C                    VALUES WITH RESPECT TO THE VARIABLE STORED IN X, TO
C                    REPLACE F AND G BY THESE VALUES, AND TO EXECUTE
C                    NLPQL1 AGAIN. IF  IFAIL = -2 , THE USER IS TO
C                    CALCULATE NEW GRADIENTS FOR OBJECTIVE FUNCTION AND
C                    ACTIVE CONSTRAINTS (ACTIVE(J) = .TRUE.), TO STORE
C                    THEM IN DF AND DG, RESPECTIVELY, AND TO CALL NLPQL1
C                    AGAIN.
C      MODE = 3 :    REVERSE COMMUNICATION IS TO BE PERFORMED AND, IN ADDITION,
C                    INITIAL GUESSES FOR MULTIPLIERS AND HESSIAN MATRIX OF THE
C                    LAGRANGE FUNCTION ARE PROVIDED BY THE USER.
C      MODE = 5,6,7,8 : SAME AS THE VERSIONS CORRESPONDING TO MODE = 0,1,2,3,
C                    RESPECTIVELY, BUT AN EXPANDED SUBPROBLEM IS FORMU-
C                    LATED, SO THAT THE ALGORITHM FOR THE SUBPROBLEM IS
C                    ALWAYS PROVIDED WITH A FEASIBLE STARTING POINT.
C      MODE = 10,11,12,13,15,16,17,18 : SAME AS THE VERSIONS CORRESPONDING TO
C                    MODE = 0,1,2,3,5,6,7,8 , RESPECTIVELY, BUT RESTARTS ARE
C                    PERFORMED IN THE ERROR CASE  IFAIL > 0 , I.E.
C                    THE APPROXIMATION OF THE HESSIAN OF THE LAGRANGE
C                    FUNCTION IS REPLACED BY THE IDENTITY MATRIX AND
C                    THE MULTIPLIER ESTIMATES BY ZERO.
C   IOUT :    INTEGER INDICATING THE DESIRED OUTPUT UNIT NUMBER, I.E. ALL
C             WRITE-STATEMENTS START WITH 'WRITE(IOUT,... '.
C   IFAIL :   THE PARAMETER SHOWS THE REASON FOR TERMINATING A SOLUTION
C             PROCESS. INITIALLY IFAIL MUST BE SET TO ZERO. ON RETURN IFAIL
C             COULD CONTAIN THE FOLLOWING VALUES:
C      IFAIL = 0 :   THE OPTIMALITY CONDITIONS ARE SATISFIED.
C      IFAIL = 1 :   THE ALGORITHM HAS BEEN STOPPED AFTER MAXIT
C                    ITERATIONS.
C      IFAIL = 2 :   THE ALGORITHM COMPUTED AN UPHILL SEARCH DIRECTION.
C      IFAIL = 3 :   UNDERFLOW OCCURED WHEN DETERMINING A NEW APPROXI-
C                    MATION MATRIX FOR THE HESSIAN OF THE LAGRANGIAN.
C      IFAIL = 4 :   MORE THAN MAXFUN FUNCTION EVALUATIONS ARE REQUIRED
C                    DURING THE LINE SEARCH ALGORITHM.
C      IFAIL = 5 :   LENGTH OF A WORKING ARRAY IS TOO SHORT. MORE
C                    DETAILED ERROR INFORMATION IS OBTAINED WITH
C                    'IPRINT > 0' .
C      IFAIL = 6 :   THERE ARE FALSE DIMENSIONS, I.E.  M > MMAX ,
C                    N >= NMAX , OR  MNN2 <> M+N+N+2 .
C      IFAIL = 7 :   THE SEARCH DIRECTION IS CLOSE TO ZERO, BUT THE
C                    CURRENT ITERATE IS STILL INFEASIBLE.
C      1000 > IFAIL > 10 :  THE SOLUTION OF THE QUADRATIC OR
C                    LEAST SQUARES SUBPROBLEM HAS BEEN TERMINATED WITH
C                    AN ERROR MESSAGE  IFQL > 0  AND IFAIL IS SET
C                    TO  IFAIL = IFQL + 10 .
C   WA(LWA),LWA :  WA IS A REAL WORKING ARRAY OF LENGTH LWA. LWA MUST BE
C             AT LEAST 4*MMAX + 4*M + 19*N + 55, IF NO GRADIENT EVALU-
C             ATIONS ARE REQUIRED IN THE LINE SEARCH, AND
C             MMAX*N + 4*MMAX + 4*M + 18*N + 55 OTHERWISE. LWA HAS TO BE
C             ENLARGED, IF ADDITIONAL WORKING SPACE IS REQUIRED TO SOLVE
C             THE QUADRATIC PROGRAMMING OR LEAST SQUARES SUBPROBLEM.
C             THE INCLUDED QP-ALGORITHM REQUIRES ADDITIONAL WORKING SPACE
C             FOR 3/2*(N+1)*(N+1) + 10*N + 2*M + 10 REAL NUMBERS, IF
C             NMAX=N+1 AND MMAX=M, RESPECTIVELY.
C   KWA(LKWA),LKWA :  THE USER HAS TO PROVIDE WORKING SPACE FOR AN
C             INTEGER ARRAY. LKWA SHOULD BE AT LEAST 19 OR GREATER,
C             IF ADDITIONAL SPACE IS REQUIRED TO SOLVE THE SUBPROBLEM.
C             THE INCLUDED QP-ALGORITHM REQUIRES M+N+N ADDITIONAL WORKING
C             ELEMENTS OF KWA.
C             THE ARRAY KWA SHOULD BE SET TO ZERO WHEN STARTING NLPQL1.
C   ACTIVE(LACTIV),LACTIV : THE LOGICAL ARRAY SHOWS A USER THE CON-
C             STRAINTS, WHICH NLPQL1 CONSIDERES TO BE ACTIVE AT THE LAST
C             COMPUTED ITERATE, I.E. G(J,X) IS ACTIVE, IF AND ONLY IF
C             ACTIVE(J) = .TRUE. , J=1,...,M. THE LENGTH LACTIV OF THE
C             LOGICAL ARRAY SHOULD BE AT LEAST 2*MMAX + 15.
C   LMERIT :  IF  LMERIT=.TRUE. , THE ALGORITHM USES THE L2-AUGMENTED
C             LAGRANGIAN PENALTY FUNCTION FOR THE LINE SEARCH. OTHER-
C             WISE THE L1-PENALTY FUNCTION ID APPLIED. IT IS RECOMMENDED
C             TO START WITH  LMERIT=.TRUE.  AND TO SWITCH TO THE L1-PENAL-
C             TY FUNCTION IN ERRROR CASES, E.G. IF  IFAIL=4 .
C   LQL :     IF  LQL = .TRUE. , THEN THE QUADRATIC PROGRAMMING SUBPROBLEM
C             IS TO BE SOLVED WITH A FULL POSITIVE DEFINITE QUASI-NEWTON
C             MATRIX. OTHERWISE, A CHOLESKY-DECOMPOSITION IS PERFORMED
C             AND UPDATED BY NLPQL1, SO THAT THE SUBPROBLEM MATRIX CONTAINS
C             AN UPPER TRIANGULAR FACTOR.
C
C   THE USER HAS TO PROVIDE A NAMED COMMON-BLOCK  /CMACHE/EPS  CONTAINING
C   A REAL NUMBER DEFINING THE UNDERLYING MACHINE PRECISION. ONE FURTHER
C   COMMON-BLOCK  /NLPQL3/  IS USED INTERNALLY AND TRANSPORTS SOME DATA 
C   FROM NLPQL1 TO NLPQL2. 
C
C
C   THE USER HAS TO PROVIDE THE FOLLOWING SUBROUTINES:
C
C   A) CALCULATION OF PROBLEM FUNCTIONS:
C
C         NLFUNC(M,ME,MMAX,N,F,G,X,ACTIVE)
C
C      DEFINITION OF PARAMETERS:
C
C      M,ME,N :       CONTAIN SOME PROBLEM PARAMETERS AS DESCRIBED ABOVE. 
C      MMAX :         DIMENSION OF G AND ACTIVE. WHEN CALLING NLFUNC, MMAX IS
C                     GREATER THAN M.
C      F :            THE USER HAS TO EVALUATE THE OBJECTIVE FUNCTION AND TO
C                     STORE THE RESULT IN F.
C      G(MMAX) :      THE USER HAS TO EVALUATE THE ACTIVE CONSTRAINTS (I.E.
C                     ALL VALUES G(J) WITH ACTIVE(J) = .TRUE.) AND TO STORE 
C                     THE RESULTS IN G. IF ANALYTICAL DIFFERENTIATION IS USED,
C                     THEN ALL CONSTRAINTS ARE EVALUATED SIMULTANEOUSLY, I.E.
C                     ACTIVE(J) = .TRUE.  FOR ALL J.
C      X(N) :         WHEN CALLING NLFUNC, X CONTAINS THE CURRENT ITERATE.
C      ACTIVE(MMAX) : LOGICAL ARRAY INDICATING THE ACTIVE CONSTRAINTS WHEN
C                     CALLING NLFUNC.
C 
C
C   B) CALCULATION OF THE GRADIENTS OF PROBLEM FUNCTIONS:
C
C         NLGRAD(M,ME,MMAX,N,F,G,DF,DG,X,ACTIVE,WA)
C
C      DEFINITION OF PARAMETERS:
C
C      M,ME,N :       CONTAIN SOME PROBLEM PARAMETERS AS DESCRIBED ABOVE.
C      MMAX :         DIMENSION OF G, ACTIVE, WA AND ROW DIMENSION OF DG.
C      F :            WHEN CALLING NLGRAD, F CONTAINS THE ACTUAL OBJECTIVE
C                     FUNCTION VALUE.
C      G(MMAX) :      WHEN CALLING NLGRAD, G CONTAINS THE ACTUAL CONSTRAINT
C                     FUNCTION VALUES.
C      DF(N) :        THE USER HAS TO EVALUATE THE GRADIENT OF THE OBJECTIVE
C                     FUNCTION AND TO STORE THE RESULTS IN DF.
C      DG(MMAX,N) :   THE USER HAS TO EVALUATE THE GRADIENTS OF ACTIVE
C                     RESTRICTIONS (ACTIVE(J) = .TRUE.) AND TO STORE THE
C                     RESULTS IN DG.
C      X(N) :         WHEN CALLING NLGRAD, X CONTAINS THE CURRENT ITERATE.
C      ACTIVE(MMAX) : LOGICAL ARRAY DETERMINING THE ACTIVE CONSTRAINTS.
C      WA(MMAX) :     WORKING ARRAY THAT CAN BE USED E.G. FOR IMPLEMENTING 
C                     A NUMERICAL DIFFERENTIATION RULE.
C      NOTE: WHENEVER NLGRAD IS CALLED, A PREVIOUS CALL OF NLFUNC WAS MADE
C            AT THE SAME ITERATE X AND F,G CONTAIN FUNCTION VALUES OF 
C            OBJECTIVE AND CONSTRAINTS AT X. X, F, AND G ARE NOT ALLOWED
C            TO BE ALTERED WITHIN DFGRAD.
C
C
C   TO EXECUTE NLPQL1, THIS FILE MUST BE COMPILED AND LINKED THE
C   USER-PROVIDED OBJECT CODES FOR FUNCTION AND GRADIENT EVALUATION, AND
C   WITH ANOTHER ONE CONTAINING THE QP-ALGORITHM, I.E. WITH THE OBJECT 
C   CODE OF FILE 'QLD.FOR'. ON A VAX/VMS-SYSTEM, IT IS RECOMMENDED TO
C   COMPILE ALL SUBROUTINES WITH THE G_FLOATING OPTION. ALL CALCULATIONS
C   WITHIN THE SUBROUTINES OF THIS FILE ARE PERFORMED IN DOUBLE PRECISION
C   ARITHMETIC.
C
C
C   AUTHOR (C):  K. SCHITTKOWSKI,
C                MATHEMATISCHES INSTITUT,
C                UNIVERSITAET BAYREUTH,
C                95440 BAYREUTH,
C                GERMANY, F.R.
C
C
C   REFERENCE:   K. SCHITTKOWSKI. NLPQL: A FORTRAN SUBROUTINE SOLVING
C                CONSTRAINED NONLINEAR PROGRAMMING PROBLEMS, ANNALS OF
C                OPERATIONS RESEARCH, VOL.5 (1985/6), 485-500.
C
C
C   VERSION:  2.6  (AUGUST, 1996)
C
C
C***********************************************************************
C
      INTEGER N,MMAX,NMAX,MNN2,LWA,LKWA,LACTIV,MO1
      LOGICAL ACTIVE,REST,LQL,LMERIT,LMER,LLISE,LLISE1,LQL1

      DOUBLE PRECISION X,G,DF,DG,U,XL,XU,C,D,WA,F,ACC,SCBOU
      DOUBLE PRECISION F1,ACC1,SCBOU1,DBDFAC,ZEFAC,RPENO,RPENS,RPENU,
     1                 ZEFACU,DELTA,BETA,AMUE,ALM

      DIMENSION X(N),G(MMAX),DF(NMAX),DG(MMAX,NMAX)
      DIMENSION XL(N),XU(N)
      
      DIMENSION U(MNN2),C(NMAX,NMAX),D(NMAX),WA(LWA)
      DIMENSION KWA(LKWA),ACTIVE(LACTIV)
      
      INTEGER M,ME,MAXFUN,MAXIT,IPRINT,MODE,IOUT,IFAIL,KWA
C
C   INTRINSIC FUNCTION: DSQRT
C
      INTEGER MODE1,MAXIT1,MAXIT2,N1,LACT,M1,M2,M3,M4,M5,M6,M7,
     1     NO1,MNN,NMNN,ISCG,ISCF,I1,I2,I3,I4,I5,I6,IVMU,IDEL,IDLA,
     2     ICLF,IBDEL,IETA,IXOLD,IDLAOL,IV,IW,IVMUOL,IDPHI,IPEN,IFB,
     3     IDFB,IGB,IDGB,IWAQL,ITEST,LWAQL,LKWA0,I,MM1,ME1,IPRIN1,
     4     IFAIL1,MAXFU1,IOUT1
      COMMON/NLPQL3/F1,ACC1,SCBOU1,DBDFAC,ZEFAC,RPENO,RPENS,RPENU,     
     1     ZEFACU,DELTA,BETA,AMUE,ALM,MM1,ME1,MAXFU1,MAXIT1,IPRIN1,
     2     MODE1,IFAIL1,LLISE1,LQL1,LMER,IOUT1
C
C   PROVIDE CONSTANT PARAMETERS FOR CALLING NLPQL2
C
      DBDFAC=2.D-1
      ZEFAC=1.D+0
      IF(.NOT.LQL) ZEFAC=DSQRT(ZEFAC)
      RPENO=1.D+1
      RPENS=1.D-2
      ZEFACU=1.D+6
      IF(.NOT.LQL) ZEFACU=DSQRT(ZEFACU)
      RPENU=1.D+9
      DELTA=9.D-1
      BETA=1.D-1
      AMUE=1.D-4
      ALM=1.D+0
      IOUT1=IOUT
      LLISE=.TRUE.
C
C     INITIALIZE SOME ARRAYS
C
      DO I=1,MNN2
      U(I)=0.0D0
      ENDDO
C
      DO I=1,NMAX
      DO J=1,NMAX
      C(I,J)=0.0D0
      ENDDO
      ENDDO
C
      DO I=1,LWA
      WA(I)=0.0D0
      ENDDO
C
      DO I=1,LKWA
      KWA(I)=0
      ENDDO
C
C   PRINT PARAMETERS
C
      IF(IPRINT.EQ.0) GOTO 50
      IF(IFAIL.LT.0) GOTO 50
      WRITE(IOUT,1000)
      CALL FLUSH(IOUT)
 1000 FORMAT(////,4X,
     1 60H------------------------------------------------------------,
     2 8H--------,
     3 /,5X,55HSTART OF THE SEQUENTIAL QUADRATIC PROGRAMMING ALGORITHM,
     4     /,4X,
     5 60H------------------------------------------------------------,
     6 8H--------)
      WRITE(IOUT,1100) MODE,ACC,SCBOU,MAXFUN,MAXIT,IPRINT
      CALL FLUSH(IOUT)
 1100 FORMAT(/,5X,11HPARAMETERS:,/,8X,6HMODE =,I3,/,8X,5HACC =,
     1     D13.4,/,8X,7HSCBOU =,D13.4,/,8X,8HMAXFUN =,I3,/,8X,7HMAXIT =,
     2     I5,/,8X,8HIPRINT =,I4)
      IF (IPRINT.NE.2) GOTO 50
C      WRITE(IOUT,1600)
C      CALL FLUSH(IOUT)
C 1600 FORMAT(/,5X,30HOUTPUT IN THE FOLLOWING ORDER:,
C     1   /,8X,24HIT    - ITERATION NUMBER,
C     2   /,8X,32HF     - OBJECTIVE FUNCTION VALUE,
C     3   /,8X,35HSCV   - SUM OF CONSTRAINT VIOLATION,
C     4   /,8X,36HNA    - NUMBER OF ACTIVE CONSTRAINTS,
C     4   /,8X,40HI     - NUMBER OF LINE SEARCH ITERATIONS,
C     5   /,8X,28HALPHA - STEPLENGTH PARAMETER,
C     6   /,8X,52HDELTA - ADDITIONAL VARIABLE TO PREVENT INCONSISTENCY,
C     8   /,8X,40HKT    - KUHN-TUCKER OPTIMALITY CRITERION)
C      WRITE(IOUT,1700)
C      CALL FLUSH(IOUT)
C 1700 FORMAT(//,6X,
C     1 'IT         F          SCV     NA  I    ALPHA     DELTA      KT',
C     3 /,4X,
C     4 60H------------------------------------------------------------,
C     5 8H--------)
   50 CONTINUE
      KWA(8)=0
      IF (MODE.LT.2000) GOTO 51
      KWA(8)=1
      MODE=2
   51 CONTINUE
      MODE1=MODE
      MAXIT1=MAXIT
      MAXIT2=MAXIT/2
      REST=.FALSE.
      IF(MODE.LT.10) GOTO 2
      REST=.TRUE.
      MODE1=MODE-10
    2 CONTINUE
C
C   INITIAL ADDRESSES IN WA
C
      N1=N+1
      LACT=2*MMAX+6
      M1=LACT+1
      M2=LACT+2
      M3=LACT+3
      M4=LACT+4
      M5=LACT+5
      M6=LACT+6
      M7=LACT+7
      NO1=N
      IF(LLISE) NO1=1
      MO1=MMAX
      IF(LLISE) MO1=1
      MNN=M+N+N
      NMNN=N+MNN
      IF(N.LT.NMAX.AND.M.LE.MMAX.AND.MNN2.EQ.MNN+2) GOTO 10
      IFAIL=6
      IF(IPRINT.EQ.0) RETURN
      WRITE(IOUT,1010)
      CALL FLUSH(IOUT)
 1010 FORMAT(8X,18H**WRONG DIMENSIONS)
      RETURN
   10 CONTINUE
      ISCG=1
      ISCF=ISCG+MMAX
      I1=ISCF+1
      I2=I1+1
      I3=I2+1
      I4=I3+1
      I5=I4+1
      I6=I5+1
      IVMU=I6+1
      IDEL=IVMU+MNN
      IDLA=IDEL+N1
      ICLF=IDLA+N
      IBDEL=ICLF+N1
      IETA=IBDEL+N
      IXOLD=IETA+N
      IDLAOL=IXOLD+N
      IV=IDLAOL+N
      IW=IV+N1
      IVMUOL=IW+N1
      IDPHI=IVMUOL+MNN
      IPEN=IDPHI+MNN+N
      IFB=IPEN+MNN
      IDFB=IFB+1
      IGB=IDFB+NO1
      IDGB=IGB+MMAX
      IWAQL=IDGB+MO1*N
      ITEST=IWAQL+MMAX+39
      LWAQL=LWA-IWAQL+1
C
C   CHECK WORKING ARRAY LENGTHS
C
      IF(ITEST.LE.LWA) GOTO 1
      IFAIL=5
      IF(IPRINT.EQ.0) RETURN
      WRITE(IOUT,1200) ITEST
      CALL FLUSH(IOUT)
 1200 FORMAT(8X,44H**LENGTH OF WA TOO SHORT. SHOULD BE AT LEAST,I6)
      RETURN
    1 IF(LKWA.GT.18) GOTO 7
      IFAIL=5
      IF(IPRINT.EQ.0) RETURN
      WRITE(IOUT,1400)
      CALL FLUSH(IOUT)
 1400 FORMAT(8X,48H**LENGTH OF KWA TOO SHORT. SHOULD BE AT LEAST 19)
      RETURN
    7 IF(LACTIV.GE.2*MMAX+15) GOTO 8
      IFAIL=5
      IF(IPRINT.EQ.0) RETURN
      WRITE(IOUT,1500)
      CALL FLUSH(IOUT)
 1500 FORMAT(8X,
     1   58H**LENGTH OF ACTIVE TOO SHORT. SHOULD BE AT LEAST 2*MMAX+15)
      RETURN
    8 CONTINUE
C
C   CHECK INITIAL POINT
C
      IF(IFAIL.LT.0) GOTO 6
      IF (MODE1.EQ.2.OR.MODE1.EQ.3) GOTO 13
      IF (MODE1.EQ.7.OR.MODE1.EQ.8) GOTO 13
      F=ALM
   13 DO5 I=1,N
      IF(X(I).LT.XL(I)) X(I)=XL(I)
    5 IF(X(I).GT.XU(I)) X(I)=XU(I)
    6 CONTINUE
      LKWA0=LKWA-7
C
C   CALL OF NLPQL2
C
    4 CONTINUE
      MM1=M
      ME1=ME
      F1=F
      ACC1=ACC
      SCBOU1=SCBOU
      MAXFU1=MAXFUN
      IPRIN1=IPRINT
      IFAIL1=IFAIL
      LLISE1=LLISE
      LQL1=LQL
      LMER=LMERIT
      CALL NLPQL2(MMAX,N,NMAX,X,G,DF,DG,U,XL,XU,C,D,WA(IVMU),WA(IDEL),     
     1     WA(IDLA),WA(ICLF),WA(IBDEL),WA(IETA),WA(IXOLD),WA(IDLAOL),
     2     WA(IV),WA(IW),WA(IVMUOL),WA(IDPHI),WA(IPEN),WA(ISCG),
     3     WA(IFB),WA(IDFB),WA(IGB),WA(IDGB),WA(IWAQL),LWAQL,N1,MNN,
     4     MNN2,NMNN,NO1,MO1,KWA(1),KWA(2),KWA(3),KWA(4),KWA(5),
     5     KWA(6),KWA(7),KWA(8),LKWA0,WA(I1),WA(I2),WA(I3),WA(I4),
     6     WA(I5),WA(ISCF),WA(I6),ACTIVE,LACT,ACTIVE(M1),ACTIVE(M2),
     7     ACTIVE(M3),ACTIVE(M4),ACTIVE(M5),ACTIVE(M6),ACTIVE(M7),
     8     IALG,F)
C      F=F1
      IFAIL=IFAIL1
      IF(.NOT.REST.OR.IFAIL.LT.1.OR.MAXIT1.LT.MAXIT2) GOTO 3
      MAXIT1=MAXIT1-10
      IF(MAXIT1.LE.0) GOTO 3
      IF(IPRINT.EQ.0) GOTO 4
      WRITE(IOUT,1300)
      CALL FLUSH(IOUT)
 1300 FORMAT(////,5X,
     1 60H------------------------------------------------------------,
     2 /,5X,7HRESTART,/,5X,
     3 60H------------------------------------------------------------)
      GOTO 4
    3 CONTINUE
C
C   END OF NLPQL1
C
      RETURN
      END
      SUBROUTINE NLPQL2(MMAX,N,NMAX,X,G,DF,DG,U,XL,XU,DCL,CD,VMU,
     1     DEL,DLA,DCLF,BDEL,ETA,XOLD,DLAOLD,V,W,VMUOLD,DPHI,RPEN,
     2     SCG,FBEST,DFBEST,GBEST,DGBEST,WA,LWA,N1,MNN,MNN2,NMNN,
     3     NO1,MO1,NFUNC,NGRAD,ITER,NQL,ILINE,IFLISE,NOPT,IW,LIW,PHI,     
     4     DFDEL,DBD,ALPHAM,ALPHAO,SCF,PROD,ACTIVE,LACTIV,LSCF,LSCG,
     5     LLINE,LREST,LALSD,LRECO,LBEST,
     6     IALG,FF)
C*********************************************************************
C
C
C   NONLINEAR PROGRAMMING BY SOLVING QUADRATIC OR LEAST SQUARES
C   SUBPROBLEMS.
C
C   THIS IS THE BASIC SUBROUTINE TO SOLVE THE NONLINEAR
C   PROGRAMMING PROBLEM.
C
C
C*********************************************************************
C
      IMPLICIT NONE
C
      INTEGER IALG,N,MNN2,MNN,NMAX,MMAX,N1,NMNN,NO1,MO1,LWA,LIW,LACTIV
      DIMENSION X(N),U(MNN2),VMU(MNN),DCL(NMAX,NMAX),DEL(N1),
     1     DLA(N),G(MMAX),DF(NMAX),DG(MMAX,NMAX),DCLF(N1),
     2     XOLD(N),DLAOLD(N),CD(NMAX),BDEL(N),ETA(N),
     3     XL(N),XU(N),V(N1),W(N1),VMUOLD(MNN),SCG(MMAX),
     4     DPHI(NMNN),RPEN(MNN),DFBEST(NO1),GBEST(MMAX),DGBEST(MO1,N),
     5     WA(LWA),IW(LIW)
      LOGICAL ACTIVE(LACTIV),LSCF,LSCG,LLINE,LREST,LALSD,LRECO,
     1     LQL,LLISE,LBEST,LMERIT
      DOUBLE PRECISION X,U,VMU,DCL,DEL,DLA,G,DF,DG,DCLF,XOLD,DLAOLD,
     1     CD,BDEL,ETA,XL,XU,V,W,VMUOLD,DPHI,RPEN,SCG,FBEST,DFBEST,
     2     GBEST,DGBEST,WA
      DOUBLE PRECISION F,ACC,SCBOU,DBDFAC,ZEFAC,RPENO,RPENS,RPENU,
     1     ZEFACU,DELTA,BETA,AMUE,ALM
      DOUBLE PRECISION SRES,PHI,SQACC,SDCL11,DCL11,DFDEL,SUM,DBD,
     1     FACT,UAD,PROD,ALPHAM,ALPHAO,EDEL,DBD1,THETA,PHIOLD,
     2     DLAN,THETA1,DBDI,EDELI,SQD,SCF,ZE,ON,TW,UF,OF,XNM,DELNM,
     3     RPMAX,FF,EPS0,CF
C
C   INTRINSIC FUNCTIONS: DOUBLE PRECISION DBLE,DSQRT,DABS,DMIN1,DMAX1
C
      INTEGER M,ME,MAXFUN,MAXIT,IPRINT,IFAIL,MODE,
     1     NFUNC,NGRAD,ITER,NQL,ILINE,IFLISE,NOPT,IW,NACT
      INTEGER IOUT,IOUT1,MN,ME1,N2,LWAQL,LIWQL,ILWLS,IMERIT,IPR,IFAIL1,
     1     MN1,MNN1,I1,I,J,MMAX2,MMAX41
      COMMON/CMACHE/EPS0
      COMMON/NLPQL3/F,ACC,SCBOU,DBDFAC,ZEFAC,RPENO,RPENS,RPENU,
     1     ZEFACU,DELTA,BETA,AMUE,ALM,M,ME,MAXFUN,MAXIT,IPRINT,
     2     MODE,IFAIL,LLISE,LQL,LMERIT,IOUT1
C
C   LOCAL VARIABLES
C
      Integer IX,JX
C
C   CONSTANT DATA
C
      ZE=0.D+0
      ON=1.D+0
      TW=2.D+0
      UF=EPS0*EPS0
      OF=ON/UF
      IOUT=IOUT1
C
C   INITIAL DEFINITIONS
C
      MN=M+N
      ME1=ME+1
      N2=N+N
      MMAX41=MMAX+41
      LWAQL=LWA-MMAX-40
      LIWQL=LIW-10
      ILWLS=2*MMAX+1
      IMERIT=0
      IF(.NOT.LMERIT) IMERIT=4
      LRECO=.FALSE.
      LREST=.FALSE.
      LALSD=.FALSE.
      SQACC=DSQRT(ACC)
      IF(MODE.NE.2.AND.MODE.NE.7.AND.MODE.NE.3.AND.MODE.NE.8) GOTO 78
      LRECO=.TRUE.
      IF(IFAIL.EQ.-1) GOTO 72
      IF(IFAIL.EQ.-2) GOTO 74
   78 ILINE=0
      ALPHAO=ZE
      NFUNC=0
      NGRAD=0
      ITER=0
      NQL=0
      NOPT=0
      IF(M.EQ.0) GOTO 51
      MMAX2=MMAX+MMAX
      DO60 J=1,M
   60 ACTIVE(J)=.TRUE.
   51 CONTINUE
      IF(LRECO) GOTO 77
      IF (M.EQ.0) GOTO 206
      DO 205 J=1,M
  205 ACTIVE(M+J)=.TRUE.
  206 CONTINUE
C
C     FIRST CALL OF FUNCTION AND GRADIENT EVALUATION
C
      OPEN (46,FILE="variables.data")
      DO IX=1,N
      WRITE (46,'(A,I4,A,E20.10)') 'X(',IX,') = ',X(IX)
      ENDDO
      CLOSE(46)  
C  
      CALL FUNC(IALG,ITER)
      F=FF
C
C     DUMP OBJECTIVE AND CONSTRAINTS BEFORE SA
C
      OPEN (46,FILE="objcon.data")
      WRITE(46,'(A,E20.10)') 'OBJECTIVE:',FF
      DO IX=1,N
      WRITE (46,'(A,I4,A,E20.10)') 'DF(',IX,') = ',DF(IX)
      ENDDO
      WRITE(46,*)
      WRITE(46,*) 'WATCH: ORDER OF CONSTRAINT MAY HAVE CHANGED'
      WRITE(46,*) 'EQUALITY CONSTRAINTS FIRST'
      WRITE(46,*)
      DO JX=1,M
      WRITE(46,'(A,I4,E20.10)') 'CONSTRAINT:',JX,G(JX)
      WRITE(46,'(A,E20.10)') 'LAGRANGE MULTIPLIER:',U(JX)
      DO IX=1,N
      WRITE (46,'(A,I4,A,I4,A,E20.10)')
     *      'DG(',JX,',',IX,') = ',DG(JX,IX)
      ENDDO
      ENDDO
      CLOSE(46)  
C
      CALL GRAD(IALG,ACTIVE(M+1))
C
      WRITE(IOUT,*)
      WRITE(IOUT,*)
      WRITE(IOUT,'(A,I5)') 'ITERATION ',ITER
      WRITE(IOUT,*)
      WRITE(IOUT,'(A)') 'VARIABLES:'
      DO IX=1,N
      WRITE (IOUT,'(A,I5,E20.10)') 'VARIABLE ',IX,X(IX)
      ENDDO      
      WRITE(IOUT,*)      
      WRITE(IOUT,'(A,E20.10)') 'OBJECTIVE:',F
      DO IX=1,N
      WRITE (IOUT,'(A,I5,E20.10)') 'GRADIENT VARIABLE ',IX,DF(IX)
      ENDDO
      WRITE(IOUT,*)      
      DO JX=1,M
      WRITE(IOUT,'(A,I5,E20.10)') 'CONSTRAINT:',JX,G(JX)
      WRITE(IOUT,'(A,E20.10)') 'LAGRANGE MULTIPLIER:',U(JX)
      DO IX=1,N
      WRITE (IOUT,'(A,I5,E20.10)') 'GRADIENT VARIABLE ',IX,DG(JX,IX)
      ENDDO
      ENDDO      
      WRITE(IOUT,*)    
      CALL FLUSH(IOUT)  
C
   77 CONTINUE
C
C     SCALING OBJECTIVE AND GRADIENT OF OBJECTIVE
C
      LSCF=.FALSE.
      LSCG=.FALSE.
      IF(DABS(F).LT.SCBOU) GOTO 160
      LSCF=.TRUE.
      IF(SCBOU.GT.ZE) SCF=ON/DSQRT(DABS(F))
      F=SCF*F
      DO161 I=1,N
  161 DF(I)=SCF*DF(I)
  160 IF(M.EQ.0) GOTO 162
      DO163 J=1,M
      IF(DABS(G(J)).LT.SCBOU) GOTO 163
      LSCG=.TRUE.
  163 CONTINUE
      IF(.NOT.LSCG) GOTO 162
      DO181 J=1,M
      IF(SCBOU.GT.ZE) SCG(J)=ON/DMAX1(ON,DSQRT(DABS(G(J))))
      G(J)=SCG(J)*G(J)
      DO164 I=1,N
  164 DG(J,I)=SCG(J)*DG(J,I)
  181 CONTINUE
  162 CONTINUE
      IF(IPRINT.LT.3) GOTO 182
      IF(LSCF.AND..NOT.LSCG) WRITE(IOUT,1410)
 1410 FORMAT(/,5X,33HOBJECTIVE FUNCTION WILL BE SCALED)
      IF(LSCF.AND.LSCG) WRITE(IOUT,1420)
 1420 FORMAT(/,5X,49HOBJECTIVE AND CONSTRAINT FUNCTIONS WILL BE SCALED)
      IF(.NOT.LSCF.AND.LSCG) WRITE(IOUT,1430)
 1430 FORMAT(/,5X,35HCONSTRAINT FUNCTIONS WILL BE SCALED)
  182 CONTINUE
      NFUNC=NFUNC+1
      NGRAD=NGRAD+1
      DCLF(N1)=ZE
      DF(N1)=ZE
      DO1 I=1,N
      DEL(I)=-DF(I)
      DCL(N1,I)=ZE
    1 DCL(I,N1)=ZE
      DEL(N1)=ZE
      DCL(N1,N1)=ZEFAC
      IF(MODE.NE.1.AND.MODE.NE.6.AND.MODE.NE.3.AND.MODE.NE.8) GOTO 80
      IF(LQL) GOTO 25
      GOTO 2
   80 CONTINUE
      DO23 I=1,N
      CD(I)=ON
      DO24 J=1,N
   24 DCL(I,J)=ZE
   23 DCL(I,I)=ON
   25 CONTINUE
      DO3 J=1,MNN
      RPEN(J)=RPENS
      VMU(J)=ZE
    3 IF(MODE.EQ.1.OR.MODE.EQ.6.OR.MODE.EQ.3.OR.MODE.EQ.8) VMU(J)=U(J)
      CALL MERIT1(IMERIT+3,M,ME,MMAX,N,MNN,NMNN,ACC,RPEN,F,DF,G,DG,        
     1     VMU,U,X,XL,XU,PHI,DPHI,ACTIVE,LACTIV,WA,4)
C
C   START MAIN LOOP, PRINT INTERMEDIATE ITERATES
C
  100 CONTINUE
      LLINE=.FALSE.
      IF(IPRINT.LT.3) GOTO 55
      CF=F
      IF(LSCF) CF=F/SCF
      WRITE(IOUT,1000) ITER,CF,(X(I),I=1,N)
      CALL FLUSH(IOUT)
 1000 FORMAT(//5X,9HITERATION,I3,//8X,23HFUNCTION VALUE:  F(X) =,
     1     D16.8,/8X,14HVARIABLE:  X =,/,(9X,4D16.8))
      IF (M.EQ.0) GOTO 165
      DO166 J=1,M
      WA(MMAX41+J)=VMU(J)
      WA(MMAX41+M+J)=G(J)
      IF(LSCF) WA(MMAX41+J)=VMU(J)/SCF
      IF(.NOT.LSCG) GOTO 166
      WA(MMAX41+J)=WA(MMAX41+J)*SCG(J)
      WA(MMAX41+M+J)=G(J)/SCG(J)
  166 CONTINUE
  165 CONTINUE
      WRITE(IOUT,1200) (WA(MMAX41+J),J=1,M),(VMU(M+J),J=1,N+N)
      CALL FLUSH(IOUT)
 1200 FORMAT(8X,17HMULTIPLIERS:  U =,/,(9X,4D16.8))
      IF(M.EQ.0) GOTO 55
      WRITE(IOUT,1120) (WA(MMAX41+M+J),J=1,M)
      CALL FLUSH(IOUT)
 1120 FORMAT(8X,19HCONSTRAINTS: G(X) =,/,(9X,4D16.8))
C
C     CONTINUE AFTER PRINTING
C
   55 CONTINUE
C
C     WRITE HESSE MATRIX AND SOLUTION IN MATLAB FORMAT
C
      IF (IPRINT.GE.3) THEN
        OPEN (46,FILE="hesse.m")
        WRITE(46,'(A,I4,A,I4,A)') 'H=zeros(',N,',',N,');'
        DO I=1,N
        WRITE(46,'(A,I4,A,E20.10,A)') 'X(',I,')=',X(I),';'
        DO J=1,N
        IF (ABS(DCL(I,J)).GT.1E-8) 
     *  WRITE(46,'(A,I4,A,I4,A,E20.10,A)') 
     *           'H(',I,',',J,')=',DCL(I,J),';' 
        ENDDO
        ENDDO
        CLOSE(46)
      ENDIF
C
      ITER=ITER+1
      IF(ITER.LT.MAXIT) GOTO 4
      IFAIL=1
      IF(IPRINT.EQ.0) GOTO 90
      WRITE(IOUT,1140)
      CALL FLUSH(IOUT)
 1140 FORMAT(8X,28H**MORE THAN MAXIT ITERATIONS)
      GOTO90
    4 CONTINUE
C
C   SEARCH DIRECTION
C
      DO71 I=1,N
      DCLF(I)=DF(I)
      V(I)=XL(I) - X(I)
   71 W(I)=XU(I) - X(I)
      IPR=0
      IF(IPRINT.GT.10.AND.IPRINT.LT.1000) IPR=IPRINT-10
      IF(MODE.GE.5) GOTO 47
      IFAIL1=ITER
      IF(LREST.OR.LALSD) IFAIL1=1
      IW(11)=0
      IF (LQL) IW(11)=1
      IW(12)=0
      CALL QL0001(M,ME,MMAX,N,NMAX,MNN,DCL,DCLF,DG,G,V,W,DEL,U,
     1     IOUT,IFAIL1,IPR,WA(MMAX41),LWAQL,IW(11),LIWQL)
      DEL(N1)=ZE
      NQL=NQL+1
      LREST=.FALSE.
      IF(IFAIL1.EQ.0) GOTO 126
   47 CONTINUE
      IF(ITER.EQ.1) GOTO 154
      IF (DEL(N1).LT.ON) THEN
         FACT=TW*DABS(DBD*DFDEL)/(DSQRT(DBD)*(ON-DEL(N1)))
      ELSE   
         FACT=TW*DABS(DBD*DFDEL)/DSQRT(DBD)
      ENDIF   
      IF(LQL) FACT=FACT*FACT
      DCL11=DMAX1(ZEFAC,FACT)
      DCL(N1,N1)=DMIN1(ZEFACU,DCL11)
  154 CONTINUE
      DO 41 I=1,N
   41 DEL(I)=ZE
      DEL(N1)=ON
      IF(M.EQ.0) GOTO 56
      DO42 J=1,M
      DG(J,N1)=-G(J)
   42 IF(.NOT.ACTIVE(J)) DG(J,N1)=ZE
   56 CONTINUE
      V(N1)=ZE
      W(N1)=ON
      IFAIL1=-ITER
      IF(.NOT.LREST.OR.LALSD) IFAIL1=-1
      IW(11)=0
      IF (LQL) IW(11)=1
      IW(12)=1
      CALL QL0001(M,ME,MMAX,N1,NMAX,MNN2,DCL,DCLF,DG,G,V,W,DEL,U,
     1     IOUT,IFAIL1,IPR,WA(MMAX41),LWAQL,IW(11),LIWQL)
      NQL=NQL+1
      MN1=M+N1+1
      MNN1=M+N1+N
      LREST=.TRUE.
      IF(IFAIL1.EQ.0) GOTO 40
   39 IFAIL=10+IFAIL1
      IF(IPRINT.EQ.0) GOTO 90
      WRITE(IOUT,1150) IFAIL1
      CALL FLUSH(IOUT)
 1150 FORMAT(8X,26H**ERROR IN QL. IFAIL(QL) =,I3)
      GOTO90
   40 CONTINUE
      DO89 I=MN1,MNN1
   89 U(I-1)=U(I)
      IF(IPRINT.LT.3) GOTO 125
      WRITE(IOUT,1250) DEL(N1)
      CALL FLUSH(IOUT)
 1250 FORMAT( 8X,45HADDITIONAL VARIABLE TO PREVENT INCONSISTENCY:,
     1     9H  DELTA =,D13.4)
      SDCL11=DCL(N1,N1)
      IF(.NOT.LQL) SDCL11=DSQRT(SDCL11)
      WRITE(IOUT,1360) SDCL11
      CALL FLUSH(IOUT)
 1360 FORMAT(8X,35HPENALTY PARAMETER FOR DELTA:  RHO =,D13.4)
  125 CONTINUE
      DCL11=DCL(N1,N1)
      IF(DEL(N1).LT.DELTA) GOTO 126
      DCL(N1,N1)=DCL11*RPENO
      IF(LQL) DCL(N1,N1)=DCL(N1,N1)*RPENO
      IF(DCL11.LT.ZEFACU) GOTO 154
C
C   AUGMENTED LAGRANGIAN TYPE SEARCH DIRECTION
C
  151 LALSD=.TRUE.
      IF(IPRINT.LT.3) GOTO 92
      WRITE(IOUT,1110)
      CALL FLUSH(IOUT)
 1110 FORMAT(8X,48H**WARNING: AUGMENTED LAGRANGIAN SEARCH DIRECTION)
   92 CALL MERIT1(4,M,ME,MMAX,N,MNN,NMNN,ACC,RPEN,F,DF,G,DG,VMU,U,
     1     X,XL,XU,PHI,DPHI,ACTIVE,LACTIV,WA,4)
      DO93 I=1,N
      WA(40+I)=DPHI(I)
   93 DCLF(I)=DPHI(I)
      IFAIL1=1
      IW(11)=0
      IF(LQL) IW(11)=1
      IW(12)=0
      CALL QL0001(0,0,MMAX,N,NMAX,MNN2,DCL,DCLF,DG,G,V,W,DEL,U,IOUT,
     1     IFAIL1,IPR,WA(MMAX41),LWAQL,IW(11),LIWQL)
      IF(IFAIL1.GT.0) GOTO 39
      IF(M.EQ.0) GOTO 129
      DO96 I=1,N2
      I1=I-1
   96 U(MNN-I1)=U(N2-I1)
      DO94 J=1,M
   94 U(J)=VMU(J) - DPHI(N+J)
      GOTO 129
  126 LALSD=.FALSE.
C
C   PROJECTION OF DEL, MAXIMAL STEPLENGTH, AND NORM OF X,DEL
C
  129 ALPHAM=OF
      XNM=ZE
      DELNM=ZE
      DO 54 I=1,N
      IF(W(I).LT.DEL(I)) DEL(I)=W(I)
      IF(V(I).GT.DEL(I)) DEL(I)=V(I)
      UAD=DABS(DEL(I))
      IF(DEL(I).GT.UF) ALPHAM=DMIN1(ALPHAM,W(I)/DEL(I))
      IF(DEL(I).LT.-UF) ALPHAM=DMIN1(ALPHAM,V(I)/DEL(I))
      XNM=DMAX1(DABS(X(I)),XNM)
   54 DELNM=DMAX1(UAD,DELNM)
      ALPHAM=DMAX1(ON,ALPHAM)
      ALPHAM=DMIN1(ALPHAM,ALM)
C
C   GRADIENT OF LAGRANGIAN
C
   18 DO 5 I=1,N
      UAD=DF(I)
      IF(LALSD) UAD=DPHI(I)
    5 DLA(I)=UAD - U(M+I) - U(MN+I)
      IF(M.EQ.0.OR.LALSD) GOTO 57
      DO6 J=1,M
      IF(U(J).EQ.ZE) GOTO 6
      DO 7 I=1,N
    7 DLA(I)=DLA(I) - DG(J,I)*U(J)
    6 CONTINUE
   57 CONTINUE
      IF(LLINE) GOTO 19
C
C   STORE SOME DATA
C
      DFDEL=ZE
      DLAN=ZE
      DO 8 I=1,N
      DFDEL=DFDEL + DF(I)*DEL(I)
      DLAOLD(I)=DLA(I)
      DLAN=DMAX1(DLAN,DABS(DLA(I)))
      XOLD(I)=X(I)
    8 CONTINUE
      DO 46 J=1,MNN
   46 VMUOLD(J)=VMU(J)
C
C   DETERMINE B*D AND D(T)*B*D
C
      DBD=ZE
      IF(LQL) GOTO 81
      DO 36 I=1,N
      SUM=ZE
      DO 37 J=I,N
   37 SUM=SUM + DCL(I,J)*DEL(J)
   36 ETA(I)=SUM
      DO 34 I=1,N
      DBD=DBD + ETA(I)*ETA(I)
      SUM=ZE
      DO 35 J=1,I
   35 SUM=SUM + DCL(J,I)*ETA(J)
   34 BDEL(I)=SUM
      GOTO 82
   81 DO 83 I=1,N
      SUM=ZE
      DO 84 J=1,N
   84 SUM=SUM + DCL(I,J)*DEL(J)
      DBD=DBD + SUM*DEL(I)
   83 BDEL(I)=SUM
   82 CONTINUE
C
C   TEST FOR OPTIMALITY AND FINAL OUTPUT
C
      SRES=ZE
      SUM=DABS(DFDEL)
      IF(LSCF) SUM=SUM/SCF
      NACT=0
      IF (M.EQ.0) GOTO 58
      DO 9 J=1,M
      IF (ACTIVE(J)) NACT=NACT + 1
      UAD=DABS(G(J))
      IF(LSCG) UAD=UAD/SCG(J)
      IF (J.LE.ME.OR.G(J).LT.ZE) SRES=SRES + UAD
    9 SUM=SUM + DABS(U(J)*G(J))
      IF (IPRINT.LT.3) GOTO 58
      WRITE(IOUT,1500) SRES
      CALL FLUSH(IOUT)
 1500 FORMAT(8X,30HSUM OF CONSTRAINT VIOLATIONS: ,19X,5HSCV =,
     1     D13.4)
      WRITE(IOUT,1510) NACT
      CALL FLUSH(IOUT)
 1510 FORMAT(8X,30HNUMBER OF ACTIVE CONSTRAINTS: ,19X,5HNAC =,I4)
   58 CONTINUE
      DO 70 I=1,N
   70 SUM=SUM + DABS(U(M+I)*V(I)) + DABS(U(MN+I)*W(I))
      IF (IPRINT.NE.2) GOTO 169
      FF=F
      IF (LSCF) FF=F/SCF
C
      WRITE(IOUT,*)
      WRITE(IOUT,*)
      WRITE(IOUT,'(A,I5)') 'ITERATION ',ITER
      WRITE(IOUT,'(A)') 
     *'----------------------------------------------------------------'
      WRITE(IOUT,*)
      WRITE(IOUT,'(A,E15.5)') 'SUM OF CONSTRAINT VIOLATION    ',SRES     
      WRITE(IOUT,'(A,E15.5)') 'STEP SIZE IN LINE SEARCH       ',ALPHAO    
      WRITE(IOUT,'(A,E15.5)') 'INCONSISTENCY VARIABLES        ',DEL(N1)    
      WRITE(IOUT,'(A,E15.5)') 'RESIDDUM OF K.T. CONDITIONS    ',SUM     
      WRITE(IOUT,'(A,I5)')    'NUMBER OF STEPS IN LINE SEARCH ',ILINE     
      WRITE(IOUT,'(A,I5)')    'NUMBER OF ACTIVE CONSTRAINTS   ',NACT     
      WRITE(IOUT,*)
      WRITE(IOUT,'(A)') 'VARIABLES:'
      DO IX=1,N
        WRITE (IOUT,'(A,I4,A,E20.10)') 'X(',IX,') = ',X(IX)
      ENDDO      
      WRITE(IOUT,*)      
      WRITE(IOUT,'(A,E20.10)') 'OBJECTIVE:',FF
      DO IX=1,N
        WRITE (IOUT,'(A,I4,A,E20.10)') 'DF(',IX,') = ',DF(IX)
      ENDDO
      WRITE(IOUT,*)      
      DO JX=1,M
        WRITE(IOUT,'(A,I4,E20.10)') 'CONSTRAINT:',JX,G(JX)
        WRITE(IOUT,'(A,E20.10)') 'LAGRANGE MULTIPLIER:',U(JX)
        DO IX=1,N
          WRITE (IOUT,'(A,I4,A,I4,A,E20.10)') 
     *          'DG(',JX,',',IX,') = ',DG(JX,IX)
        ENDDO
      ENDDO      
      WRITE(IOUT,*)      
      CALL FLUSH(IOUT)
C
 1460 FORMAT(3X,I5,D16.8,D10.2,I4,I3,3D10.2)
C
  169 CONTINUE
      IF (IPRINT.LT.3) GOTO 200
      WRITE(IOUT,1520) SUM
      CALL FLUSH(IOUT)
 1520 FORMAT(8X,40HKUHN-TUCKER OPTIMALITY CONDITION:       ,
     1     9X,5HKTO =,D13.4)
      WRITE(IOUT,1530) DLAN
      CALL FLUSH(IOUT)
 1530 FORMAT(8X,40HNORM OF LAGRANGIAN GRADIENT:            ,
     1     9X,5HNLG =,D13.4)
  200 CONTINUE
      IF (DBD.GE.UF) GOTO 43
      IF (SRES.LT.SQACC) GOTO 59
      IF (DBD.GT.ZE) GOTO 127
      IF (.NOT.LALSD) GOTO 151
      IFAIL=7
      IF (IPRINT.EQ.0) GOTO 90
      WRITE(IOUT,1440)
      CALL FLUSH(IOUT)
 1440 FORMAT(8X,48H**UNDERFLOW IN D(T)*B*D AND INFEASIBLE ITERATE X)
      GOTO 90
   43 CONTINUE
      IF (SUM.GE.ACC.OR.SRES.GT.SQACC) GOTO 127
      IF (DLAN.LE.DSQRT(SQACC).OR.DBD.LE.ACC) GOTO 59
      NOPT=NOPT+1
      IF (NOPT.LT.3) GOTO 127
   59 IFAIL=0
   90 CONTINUE
      IF (LSCF) F=F/SCF
      IF (M.EQ.0.OR.(.NOT.LSCF.AND..NOT.LSCG)) GOTO 171
      DO 170 J=1,M
      IF (LSCF) U(J)=U(J)/SCF
      IF (.NOT.LSCG) GOTO 170
      U(J)=U(J)*SCG(J)
      G(J)=G(J)/SCG(J)
  170 CONTINUE
  171 CONTINUE
      IF (IPRINT.EQ.0) GOTO 9999
      WRITE(IOUT,1270)
      CALL FLUSH(IOUT)
 1270 FORMAT(//,5X,28H* FINAL CONVERGENCE ANALYSIS,/)
      WRITE(IOUT,1280) F
      CALL FLUSH(IOUT)
 1280 FORMAT(8X,33HOBJECTIVE FUNCTION VALUE:  F(X) =,D16.8)
      WRITE(IOUT,1290) (X(I),I=1,N)
      CALL FLUSH(IOUT)
 1290 FORMAT(8X,31HAPPROXIMATION OF SOLUTION:  X =,/,(9X,4D16.8))
      WRITE(IOUT,1300) (U(J),J=1,MNN)
      CALL FLUSH(IOUT)
 1300 FORMAT(8X,34HAPPROXIMATION OF MULTIPLIERS:  U =,/,(9X,4D16.8))
      IF (M.EQ.0) GOTO 131
      WRITE(IOUT,1310) (G(J),J=1,M)
      CALL FLUSH(IOUT)
 1310 FORMAT(8X,26HCONSTRAINT VALUES:  G(X) =,/,(9X,4D16.8))
  131 WRITE(IOUT,1320) (V(I),I=1,N)
      CALL FLUSH(IOUT)
 1320 FORMAT(8X,34HDISTANCE FROM LOWER BOUND:  XL-X =,/,(9X,4D16.8))
      WRITE(IOUT,1330) (W(I),I=1,N)
      CALL FLUSH(IOUT)
 1330 FORMAT(8X,34HDISTANCE FROM UPPER BOUND:  XU-X =,/,(9X,4D16.8))
      IF (.NOT.LLISE) WRITE(IOUT,1450) ITER
 1450 FORMAT(8X,29HNUMBER OF ITERATIONS:  ITER =,I4)
      WRITE(IOUT,1390) NFUNC
      CALL FLUSH(IOUT)
 1390 FORMAT(8X,30HNUMBER OF FUNC-CALLS:  NFUNC =,I4)
      WRITE(IOUT,1340) NGRAD
      CALL FLUSH(IOUT)
 1340 FORMAT(8X,30HNUMBER OF GRAD-CALLS:  NGRAD =,I4)
      WRITE(IOUT,1400) NQL
      CALL FLUSH(IOUT)
 1400 FORMAT(8X,30HNUMBER OF QL-CALLS:    NQL   =,I4,///)
      GOTO 9999
  127 CONTINUE
C
C   CORRECT PENALTY PARAMETER
C
      IF (LALSD) GOTO 87
      WA(1)=DBD
      WA(2)=DEL(N1)
      WA(3)=RPENU
      WA(4)=DBLE(ITER)
      CALL MERIT1(IMERIT+2,M,ME,MMAX,N,MNN,NMNN,ACC,RPEN,F,DF,G,DG,
     1     VMU,U,X,XL,XU,PHI,DPHI,ACTIVE,LACTIV,WA,4)
      GOTO 99
   87 SUM=ZE
      DO 88 I=1,N
   88 SUM=SUM + DPHI(I)*DEL(I) + DABS(U(M+I)*V(I)) + DABS(U(MN+I)*W(I))
      IF (SUM.GT.DSQRT(SQACC)) GOTO 99
      DO97 J=1,MNN
   97 RPEN(J)=DMIN1(ZEFACU,RPEN(J)*RPENO)
      CALL MERIT1(IMERIT+4,M,ME,MMAX,N,MNN,NMNN,ACC,RPEN,F,DF,G,DG,
     1     VMU,U,X,XL,XU,PHI,DPHI,ACTIVE,LACTIV,WA,4)
   99 IF (IPRINT.LT.3) GOTO 123
      WRITE(IOUT,1260) DBD
      CALL FLUSH(IOUT)
 1260 FORMAT(8X,46HPRODUCT OF SEARCH DIRECTION WITH BFGS-MATRIX: ,
     1     8H   DBD =,D13.4)
      WRITE(IOUT,1230) (RPEN(J),J=1,MNN)
      CALL FLUSH(IOUT)
 1230 FORMAT(8X,23HPENALTY PARAMETER:  R =,/,(9X,4D16.8))
  123 CONTINUE
C
C   EVALUATION OF MERIT FUNCTION
C
   95 CALL MERIT1(IMERIT+3,M,ME,MMAX,N,MNN,NMNN,ACC,RPEN,F,DF,G,DG,
     1     VMU,U,X,XL,XU,PHI,DPHI,ACTIVE,LACTIV,WA,4)
      IF (.NOT.LALSD) CALL MERIT1(IMERIT+4,M,ME,MMAX,N,MNN,NMNN,ACC,
     1     RPEN,F,DF,G,DG,VMU,U,X,XL,XU,PHI,DPHI,ACTIVE,LACTIV,WA,4)         
      PROD=ZE
      DO 44 I=1,N
   44 PROD=PROD + DPHI(I)*DEL(I)
      DO 45 J=1,MNN
   45 PROD=PROD + DPHI(J+N)*(U(J) - VMU(J))
      PHIOLD=PHI
      IF (PROD.LT.ZE) GOTO 28
      RPMAX=ZE
      DO 91 J=1,MNN
      RPEN(J)=RPEN(J)*RPENO
   91 RPMAX=DMAX1(RPMAX,RPEN(J))
      IF (RPMAX.LT.RPENU) GOTO 95
      IF (LALSD) GOTO 98
      IF (.NOT.LREST.OR.DBD.LT.ACC) GOTO 151
      DCL11=DCL(N1,N1)
      IF (DCL11.GE.ZEFACU) GOTO 151
      DCL11=DCL11*RPENO
      IF(LQL) DCL11=DCL11*RPENO
      DCL(N1,N1)=DCL11
      GOTO 154
   98 CONTINUE
      IFAIL=2
      IF (IPRINT.EQ.0) GOTO 90
      WRITE(IOUT,1180) PROD
      CALL FLUSH(IOUT)
 1180 FORMAT(8X,44H**SEARCH DIRECTION NOT PROFITABLE:  DPHI*P =,D13.4)
      GOTO 90
   28 CONTINUE
      IF (IPRINT.LT.3) GOTO 135
      WRITE(IOUT,1350) PROD
      CALL FLUSH(IOUT)
 1350 FORMAT(8X,33HPRODUCT LAGRANGIAN GRADIENT WITH ,
     1     24HSEARCH DIRECTION:  DLP =,D13.4)
  135 CONTINUE
C
C   LINE SEARCH
C
      WA(6)=XNM
      WA(7)=DELNM
      LBEST=.FALSE.
      IFLISE=0
   14 IPR=0
      IF (IPRINT.GE.1000) IPR=IPRINT-1000
      IF ((IPRINT.NE.4).OR.(IFLISE.GE.0)) GOTO 281
      WRITE(IOUT,2810) ILINE,ALPHAO,PHI
      CALL FLUSH(IOUT)
  281 CONTINUE
 2810 FORMAT(7X,21H*** LINE SEARCH STEP ,I2,10H: ALPHA = ,D11.4, 
     1     14H, MERIT FCT = ,D13.6)
      CALL LINSEA(ALPHAO,ALPHAM,PHI,PROD,AMUE,BETA,ILINE,MAXFUN,IFLISE,
     1     IPR,WA(6),35,IW,10,ACTIVE(ILWLS),5)
      IF (IFLISE.GT.-2) GOTO 192
      LBEST=.TRUE.
      FBEST=F
      IF (M.EQ.0) GOTO 193
      DO 194 J=1,M
  194 GBEST(J)=G(J)
  193 IF (LLISE) GOTO 14
      DO 195 I=1,N
      DFBEST(I)=DF(I)
      IF (M.EQ.0) GOTO 195
      DO 196 J=1,M
  196 DGBEST(J,I)=DG(J,I)
  195 CONTINUE
      GOTO 14
  192 CONTINUE
      IF (IFLISE.EQ.1) GOTO 10
      IF (IFLISE.GT.1) GOTO 15
      DO 11 I=1,N
   11 X(I)=XOLD(I) + ALPHAO*DEL(I)
      DO 12 J=1,MNN
   12 VMU(J)=VMUOLD(J) + ALPHAO*(U(J) - VMUOLD(J))
      IF (IFLISE.EQ.0) GOTO 13
      GOTO 197
   15 IFAIL=1000+IFLISE
      IF (IPRINT.EQ.0) GOTO 90
      WRITE(IOUT,1160) IFLISE
      CALL FLUSH(IOUT)
 1160 FORMAT(8X,32H**ERROR IN LINE SEARCH. IFLISE =,I4)
      GOTO 90
   10 IFAIL=4
      IF (IPRINT.EQ.0) GOTO 90
      WRITE(IOUT,1130)
      CALL FLUSH(IOUT)
 1130 FORMAT(8X,44H**MORE THAN MAXFUN FUNC-CALLS IN LINE SEARCH)
      GOTO 90
   13 LLINE=.TRUE.
      IF (IPRINT.LT.3) GOTO 117
      IF (ILINE.EQ.1) WRITE(IOUT,1090)
 1090 FORMAT(8X,50HLINE SEARCH SUCCESSFUL AFTER ONE STEP:  ALPHA = 1.)
      IF (ILINE.GT.1) WRITE(IOUT,1170) ILINE,ALPHAO
 1170 FORMAT(8X,28HLINE SEARCH SUCCESSFUL AFTER,I3,7H STEPS:,
     1     9H  ALPHA =,D13.4)
  117 CONTINUE
      IF (.NOT.LBEST.AND.LLISE) GOTO 17
      IF (.NOT.LBEST.AND..NOT.LLISE) GOTO 18
      F=FBEST
      IF (M.EQ.0) GOTO 198
      DO199 J=1,M
  199 G(J)=GBEST(J)
  198 IF (LLISE) GOTO 17
      DO 201 I=1,N
      DF(I)=DFBEST(I)
      IF (M.EQ.0) GOTO 201
      DO 202 J=1,M
  202 DG(J,I)=DGBEST(J,I)
  201 CONTINUE
      CALL MERIT1(IMERIT+1,M,ME,MMAX,N,MNN,NMNN,ACC,RPEN,F,DF,G,DG,
     1     VMU,U,X,XL,XU,PHI,DPHI,ACTIVE,LACTIV,WA,4)
      GOTO 18
  197 CONTINUE
C
C   NEW FUNCTION AND GRADIENT VALUES
C
      IF (.NOT.LRECO) GOTO 73
      IFAIL=-1
      GOTO 9999
   73 CONTINUE
      IF (M.EQ.0) GOTO 204
      DO 203 J=1,M
  203 ACTIVE(M+J)=.TRUE.
  204 CONTINUE
c
      OPEN (46,FILE="variables.data")
      DO IX=1,N
        WRITE (46,'(A,I4,A,E20.10)') 'X(',IX,') = ',X(IX)
      ENDDO
      CLOSE(46)  
C  
      CALL FUNC(IALG,ITER)
      F=FF
c
c     DUMP OBJECTIVE AND CONSTRAINTS BEFORE SA
c
      OPEN (46,FILE="objcon.data")
         WRITE(46,'(A,E20.10)') 'OBJECTIVE:',FF
         DO IX=1,N
           WRITE (46,'(A,I4,A,E20.10)') 'DF(',IX,') = ',DF(IX)
         ENDDO
         WRITE(46,*)
         DO JX=1,M
           WRITE(46,'(A,I4,E20.10)') 'CONSTRAINT:',JX,G(JX)
           WRITE(46,'(A,E20.10)') 'LAGRANGE MULTIPLIER:',U(JX)
           DO IX=1,N
             WRITE (46,'(A,I4,A,I4,A,E20.10)')
     *  	   'DG(',JX,',',IX,') = ',DG(JX,IX)
           ENDDO
         ENDDO
      CLOSE(46)  
C
   72 CONTINUE
      IF (LSCF) F=F*SCF
      IF (M.EQ.0.OR..NOT.LSCG) GOTO 172
      DO 173 J=1,M
  173 G(J)=SCG(J)*G(J)
  172 CONTINUE
      NFUNC=NFUNC+1
      CALL MERIT1(IMERIT+3,M,ME,MMAX,N,MNN,NMNN,ACC,RPEN,F,DF,G,DG,
     1     VMU,U,X,XL,XU,PHI,DPHI,ACTIVE,LACTIV,WA,4)
      IF (LLISE.AND..NOT.LLINE) GOTO 14
   17 CONTINUE
      CALL MERIT1(IMERIT+1,M,ME,MMAX,N,MNN,NMNN,ACC,RPEN,F,DF,G,DG,
     1     VMU,U,X,XL,XU,PHI,DPHI,ACTIVE,LACTIV,WA,4)
      IF(LSCF) F=F/SCF
      IF(M.EQ.0.OR..NOT.LSCG) GOTO174
      DO175 J=1,M
      G(J)=G(J)/SCG(J)
      DO175 I=1,N
      DG(J,I)=DG(J,I)/SCG(J)
  175 CONTINUE
  174 CONTINUE
      IF(.NOT.LRECO) GOTO75
      IFAIL=-2
      GOTO 9999
   75 CONTINUE
C   
      CALL GRAD(IALG,ACTIVE(M+1))
C
   74 CONTINUE
      NGRAD=NGRAD+1
      IF(.NOT.LSCF) GOTO176
      F=F*SCF
      DO177 I=1,N
  177 DF(I)=SCF*DF(I)
  176 IF(M.EQ.0.OR..NOT.LSCG) GOTO178
      DO179 J=1,M
      G(J)=G(J)*SCG(J)
      DO180 I=1,N
  180 DG(J,I)=DG(J,I)*SCG(J)
  179 CONTINUE
  178 CONTINUE
      IF(LLINE) GOTO18
      CALL MERIT1(IMERIT+4,M,ME,MMAX,N,MNN,NMNN,ACC,RPEN,F,DF,G,DG,
     1     VMU,U,X,XL,XU,PHI,DPHI,ACTIVE,LACTIV,WA,4)
      PROD=ZE
      DO190 I=1,N
  190 PROD=PROD + DPHI(I)*DEL(I)
      DO191 J=1,MNN
  191 PROD=PROD + DPHI(N+J)*(U(J) - VMUOLD(J))
      GOTO14
C
C   UPDATE HESSIAN OF LAGRANGIAN
C
   19 EDEL=ZE
      DBD=DBD*ALPHAO*ALPHAO
      DO20 I=1,N
      BDEL(I)=BDEL(I)*ALPHAO
      ETA(I)=DLA(I) - DLAOLD(I)
   20 EDEL=EDEL + ALPHAO*DEL(I)*ETA(I)
      DBD1=DBDFAC*DBD
      IF(EDEL.GE.DBD1) GOTO31
      THETA=(DBD - DBD1)/(DBD - EDEL)
      THETA1=ON - THETA
      DO32 I=1,N
   32 ETA(I)=THETA*ETA(I) + THETA1*BDEL(I)
   33 EDEL=DBD1
   31 CONTINUE
      DBDI=DSQRT(ON/DBD)
      EDELI=DSQRT(ON/EDEL)
C
C   UPDATE FACTORIZATION
C
      DO22 I=1,N
      BDEL(I)=DBDI*BDEL(I)
   22 ETA(I)=EDELI*ETA(I)
      IF(.NOT.LQL) GOTO85
      DO86 I=1,N
      DO86 J=I,N
      DCL(I,J)=DCL(I,J) + ETA(I)*ETA(J) - BDEL(I)*BDEL(J)
   86 DCL(J,I)=DCL(I,J)
C
C   PERFORM NEXT ITERATION
C
      GOTO100
   85 CONTINUE
      CALL LDL001(N,NMAX,DCL,CD,ETA,BDEL)
C
C   CORRECT DATA FOR QL-SOLUTION
C
    2 DO48 I=1,N
      SQD=DSQRT(CD(I))
      IF(SQD.GT.UF) GOTO21
      IFAIL=3
      IF(IPRINT.EQ.0) GOTO90
      WRITE(IOUT,1370)
      CALL FLUSH(IOUT)
 1370 FORMAT(8X,26H**UNDERFLOW IN BFGS-UPDATE)
      GOTO 90
   21 CONTINUE
      I1=I+1
      IF (I1.GT.N) GOTO 50
      DO49 J=I1,N
   49 DCL(I,J)=SQD*DCL(J,I)
   50 DCL(I,I)=SQD
   48 CONTINUE
      IF (ITER.EQ.0) GOTO 25
C
C   PERFORM NEXT ITERATION
C
      GOTO100
C
C   END OF NLPQL2
C
 9999 RETURN
      END
      SUBROUTINE LDL001(N,NMAX,CL,D,U,V)
C
C********************************************************************
C
C
C   UPDATE CHOLESKEY FACTORIZATION
C
C     L*D*L(T) = L*D*L(T) + U*U(T) - V*V(T)
C
C
C********************************************************************
C
      INTEGER N,NMAX
      DIMENSION CL(NMAX,N),D(N),U(N),V(N)
      INTEGER R,J,J1,I,I1,N1
      DOUBLE PRECISION CL,D,U,V,EPS,T,ON,ZE,FO,PJ,DJ,TNEW,TT,TTI, 
     1     DJNEW,BETA,CLRJ,PDP,SUM,UI
      COMMON/CMACHE/EPS
C
C   CONSTANT DATA
C
      ON=1.D+0
      ZE=0.D+0
      FO=4.D+0
C
C   UPDATE L*D*L(T) + U*U(T)
C
      T=ON
      DO1 J=1,N
      PJ=U(J)
      DJ=D(J)
      TNEW=T + PJ*PJ/DJ
      TT=TNEW/T
      TTI=ON/TT
      DJNEW=DJ*TT
      BETA=PJ/(DJ*TNEW)
      J1=J+1
      IF(J1.GT.N) GOTO5
      IF(DJNEW.LE.FO*DJ) GOTO2
      DO3 R=J1,N
      CLRJ=CL(R,J)
      CL(R,J)=TTI*CLRJ + BETA*U(R)
    3 U(R)=U(R) - PJ*CLRJ
      GOTO5
    2 DO4 R=J1,N
      U(R)=U(R) - PJ*CL(R,J)
    4 CL(R,J)=CL(R,J) + BETA*U(R)
    5 T=TNEW
      D(J)=DJNEW
    1 CONTINUE
C
C   UPDATE L*D*L(T) - V*V(T)
C
      U(1)=V(1)
      PDP=U(1)*U(1)/D(1)
      DO6 I=2,N
      SUM=ZE
      I1=I-1
      DO7 J=1,I1
    7 SUM=SUM + CL(I,J)*U(J)
      UI=V(I) - SUM
      PDP=PDP + UI*UI/D(I)
    6 U(I)=UI
C
      T=ON - PDP
      IF(T.LE.EPS) T=EPS
C
      N1=N+1
      DO8 I=1,N
      J=N1-I
      PJ=U(J)
      DJ=D(J)
      TNEW=T + PJ*PJ/DJ
      TT=T/TNEW
      DJNEW=DJ*TT
      BETA=-PJ/(DJ*T)
      V(J)=PJ
      T=TNEW
      D(J)=DJNEW
      J1=J+1
      IF(J1.GT.N) GOTO8
      DO9 R=J1,N
      CLRJ=CL(R,J)
      CL(R,J)=CLRJ + BETA*V(R)
    9 V(R)=V(R) + PJ*CLRJ
    8 CONTINUE
C
C   END OF LDL001
C
      RETURN
      END
C
      SUBROUTINE LINSEA(ALPHA,ALPHAM,PHI,DPHI,AMUE,BETA,ILINE,MAXFUN,
     1     IFAIL,IPRINT,WA,LWA,KWA,LKWA,LOWA,LLOWA)
C
C*********************************************************************
C
C
C   LINE SEARCH ALGORITHM BASED ON QUADRATIC INTERPOLATION AND ARMIJO-
C   TYPE STOPPING CRITERION.
C
C
C*********************************************************************
C
      INTEGER LWA,LKWA,LLOWA
      DIMENSION WA(LWA),KWA(LKWA),LOWA(LLOWA)
      DOUBLE PRECISION ALPHA,ALPHAM,PHI,DPHI,AMUE,BETA,WA,HA,ON,DIFF 
C
C   INTRINSIC FUNCTION:  DMAX1
C
      INTEGER ILINE,MAXFUN,IFAIL,IPRINT,KWA   
      LOGICAL LOWA
C
C   CONSTANT PARAMETERS
C
      HA=5.D-1
      ON=1.D+0
C
C   START LINE SEARCH
C
      IF (IFAIL.EQ.-1) GOTO 1
      WA(1)=PHI
      ILINE=0
      ALPHA=ALPHAM
      WA(2)=ALPHA
    2 ILINE=ILINE+1
      DPHI=DPHI*WA(2)
      IFAIL=-1
      GOTO 9999
    1 IF (ILINE.LT.MAXFUN) GOTO 3
      IFAIL=1
      GOTO 9999
    3 DIFF=PHI - WA(1)
      IF(KWA(1).EQ.1) GOTO 6
      IF (DIFF.GT.AMUE*DPHI) GOTO 4
      IFAIL=0
      GOTO 9999
    4 WA(2)=DMAX1(BETA,HA*DPHI/(DPHI - DIFF))
      GOTO 5
    6 WA(2)=BETA
    5 ALPHA=WA(2)*ALPHA
      GOTO2
C
C   END OF LINSEA
C
 9999 RETURN
      END
      SUBROUTINE MERIT1(MODE,M,ME,MMAX,N,MNN,NMNN,ACC,R,F,DF,G,DG,V,U,
     1     X,XL,XU,PHI,DPHI,ACTIVE,LACTIV,WA,LWA)
C
C*********************************************************************
C
C
C   FUNCTION AND GRADIENT EVALUATIONS OF THE AUGMENTED LAGRANGIAN
C   MERIT FUNCTION, PENALTY PARAMETERS, AND ACTIVE SET
C
C
C*********************************************************************
C
      INTEGER MNN,N,MMAX,NMNN,LWA,LACTIV
      DIMENSION R(MNN),DF(N),G(MMAX),DG(MMAX,N),V(MNN),U(MNN),X(N),
     1     XL(N),XU(N),DPHI(NMNN),ACTIVE(LACTIV),WA(LWA)
      DOUBLE PRECISION ACC,R,F,DF,G,DG,V,U,X,XL,XU,PHI,DPHI,WA
      INTEGER MODE,M,ME
      LOGICAL ACTIVE
      DOUBLE PRECISION FACT,RNEW,UAD,PHI1,RMJ,RMI,RMNJ,RMNI,VMI,VMNI,
     1     XMXL,XUMX,SUM,ZE,UF,HA,ON,EPS
C
C INTRINSIC FUNCTIONS:  DSQRT,DBLE,DMIN1,DMAX1
C
      INTEGER ME1,J,MN,I
      COMMON/CMACHE/EPS
C
C   CONSTANT DATA
C
      ZE=0.D+0
      UF=EPS*EPS
      HA=5.D-1
      ON=1.D+0
      GOTO(1,2,3,3,5,6,7,8),MODE
C
C   EVALUATION OF ACTIVE SET
C
    1 IF(M.EQ.0.OR.ME.EQ.M) GOTO10
      ME1=ME+1
      DO11 J=ME1,M
      ACTIVE(J)=.TRUE.
   11 IF(V(J).EQ.ZE.AND.G(J).GT.ACC) ACTIVE(J)=.FALSE.
   10 RETURN
C
C   EVALUATION OF PENALTY PARAMETER
C
    2 FACT=WA(3)
      IF(WA(1).GT.UF) FACT=DBLE(2*M)/(WA(1) + (ON-WA(2)))
      DO20 J=1,MNN
      RNEW=DMIN1(WA(3),FACT*(U(J) - V(J))**2)
      UAD=DMIN1(R(J),WA(4)*DSQRT(R(J)))
   20 R(J)=DMAX1(RNEW,UAD)
      RETURN
C
C   PREPARE EVALUATION OF AUGMENTED LAGRANGIAN
C
    3 IF(M.EQ.0) GOTO30
      DO31 J=1,M
      ACTIVE(M+J)=.TRUE.
   31 IF(J.GT.ME.AND.R(J)*G(J).GT.V(J)) ACTIVE(M+J)=.FALSE.
   30 CONTINUE
      IF(MODE.EQ.4) GOTO4
C
C   EVALUATION OF AUGMENTED LAGRANGIAN VALUE
C
      PHI=F
      IF(M.EQ.0) GOTO32
      DO33 J=1,M
      IF(ACTIVE(M+J)) PHI1=(V(J) - HA*R(J)*G(J))*G(J)
      IF(.NOT.ACTIVE(M+J)) PHI1=HA*V(J)*V(J)/R(J)
   33 PHI=PHI - PHI1
   32 CONTINUE
      MN=M+N
      DO34 I=1,N
      RMJ=R(M+I)
      RMI=ON/RMJ
      RMNJ=R(MN+I)
      RMNI=ON/RMNJ
      VMI=V(M+I)
      VMNI=V(MN+I)
      XMXL=X(I) - XL(I)
      XUMX=XU(I) - X(I)
      IF(XMXL.LE.VMI*RMI) PHI=PHI - (VMI-HA*RMJ*XMXL)*XMXL
      IF(XMXL.GT.VMI*RMI) PHI=PHI - HA*RMI*VMI*VMI
      IF(XUMX.LE.VMNI*RMNI) PHI=PHI - (VMNI-HA*RMNJ*XUMX)*XUMX
      IF(XUMX.GT.VMNI*RMNI) PHI=PHI - HA*RMNI*VMNI*VMNI
   34 CONTINUE
      RETURN
C
C   GRADIENT EVALUATION OF AUGMENTED LAGRANGIAN
C
    4 DO42 I=1,N
      DPHI(I)=DF(I)
      SUM=ZE
      IF(M.EQ.0) GOTO42
      DO43 J=1,M
   43 IF(ACTIVE(M+J)) SUM=SUM + DG(J,I)*(V(J) - R(J)*G(J))
   42 DPHI(I)=DPHI(I) - SUM
      IF(M.EQ.0) GOTO44
      DO45 J=1,M
      IF(ACTIVE(M+J)) DPHI(N+J)=-G(J)
   45 IF(.NOT.ACTIVE(M+J)) DPHI(N+J)=-V(J)/R(J)
   44 CONTINUE
      MN=M+N
      DO46 I=1,N
      VMI=V(M+I)
      VMNI=V(MN+I)
      XMXL=X(I) - XL(I)
      XUMX=XU(I) - X(I)
      RMJ=R(M+I)
      RMI=ON/RMJ
      RMNJ=R(MN+I)
      RMNI=ON/RMNJ
      IF(XMXL.LE.VMI*RMI) DPHI(I)=DPHI(I) - VMI + RMJ*XMXL
      IF(XUMX.LE.VMNI*RMNI) DPHI(I)=DPHI(I) + VMNI - RMNJ*XUMX
      IF(XMXL.LE.VMI*RMI) DPHI(MN+I)=-XMXL
      IF(XMXL.GT.VMI*RMI) DPHI(MN+I)=-VMI*RMI
      IF(XUMX.LE.VMNI*RMNI) DPHI(MNN+I)=-XUMX
      IF(XUMX.GT.VMNI*RMNI) DPHI(MNN+I)=-VMNI*RMNI
   46 CONTINUE
      RETURN
C
C   EVALUATION OF L1-PENALTY FUNCTION
C
C   ACTIVE SET
C
    5 IF(M.EQ.0) GOTO9
      DO12 J=1,M
   12 ACTIVE(J)=.TRUE.
    9 RETURN
C
C   PENALTY PARAMETER
C
    6 DO13 J=1,MNN
      PHI1=DABS(U(J))
   13 R(J)=DMAX1(PHI1,HA*(R(J)+PHI1))
      RETURN
C
C   MERIT FUNCTION VALUE
C
    7 PHI=F
      IF(M.EQ.0) GOTO14
      DO15 J=1,M
      PHI1=DABS(G(J))
      IF(J.GT.ME.AND.G(J).GT.ZE) PHI1=ZE
   15 PHI=PHI + R(J)*PHI1
   14 RETURN
C
C   GRADIENT OF MERIT FUNCTION
C
    8 DO16 J=N,NMNN
   16 DPHI(J)=ZE
      DO17 I=1,N
      DPHI(I)=DF(I)
      IF(M.EQ.0) GOTO17
      PHI1=ZE
      DO18 J=1,M
      IF(G(J).GT.ZE.AND.J.LE.ME) PHI1=PHI1 + R(J)*DG(J,I)
   18 IF(G(J).LE.ZE) PHI1=PHI1 - R(J)*DG(J,I)
      DPHI(I)=DPHI(I) + PHI1
   17 CONTINUE
      RETURN
C
C   END OF MERIT1
C
      END
      SUBROUTINE QL0001(M,ME,MMAX,N,NMAX,MNN,C,D,A,B,XL,XU,
     1      X,U,IOUT,IFAIL,IPRINT,WAR,LWAR,IWAR,LIWAR)
C
C**************************************************************************
C
C
C             SOLUTION OF QUADRATIC PROGRAMMING PROBLEMS
C
C
C
C   QL0001 SOLVES THE QUADRATIC PROGRAMMING PROBLEM
C
C   MINIMIZE        .5*X'*C*X + D'*X
C   SUBJECT TO      A(J)*X  +  B(J)   =  0  ,  J=1,...,ME
C                   A(J)*X  +  B(J)  >=  0  ,  J=ME+1,...,M
C                   XL  <=  X  <=  XU
C   
C   HERE C MUST BE AN N BY N SYMMETRIC AND POSITIVE MATRIX, D AN N-DIMENSIONAL
C   VECTOR, A AN M BY N MATRIX AND B AN M-DIMENSIONAL VECTOR. THE ABOVE
C   SITUATION IS INDICATED BY IWAR(1)=1. ALTERNATIVELY, I.E. IF IWAR(1)=0,
C   THE OBJECTIVE FUNCTION MATRIX CAN ALSO BE PROVIDED IN FACTORIZED FORM.
C   IN THIS CASE, C IS AN UPPER TRIANGULAR MATRIX.
C
C   THE SUBROUTINE REORGANIZES SOME DATA SO THAT THE PROBLEM CAN BE SOLVED
C   BY A MODIFICATION OF AN ALGORITHM PROPOSED BY POWELL (1983).
C
C
C   USAGE:
C
C      QL0001(M,ME,MMAX,N,NMAX,MNN,C,D,A,B,XL,XU,X,U,IOUT,IFAIL,IPRINT,
C             WAR,LWAR,IWAR,LIWAR)
C
C
C   DEFINITION OF THE PARAMETERS:
C
C   M :        TOTAL NUMBER OF CONSTRAINTS.
C   ME :       NUMBER OF EQUALITY CONSTRAINTS.
C   MMAX :     ROW DIMENSION OF A. MMAX MUST BE AT LEAST ONE AND GREATER
C              THAN M.
C   N :        NUMBER OF VARIABLES.
C   NMAX :     ROW DIMENSION OF C. NMAX MUST BE GREATER OR EQUAL TO N.
C   MNN :      MUST BE EQUAL TO M + N + N.
C   C(NMAX,NMAX): OBJECTIVE FUNCTION MATRIX WHICH SHOULD BE SYMMETRIC AND
C              POSITIVE DEFINITE. IF IWAR(1) = 0, C IS SUPPOSED TO BE THE
C              CHOLESKEY-FACTOR OF ANOTHER MATRIX, I.E. C IS UPPER
C              TRIANGULAR.
C   D(NMAX) :  CONTAINS THE CONSTANT VECTOR OF THE OBJECTIVE FUNCTION.
C   A(MMAX,NMAX): CONTAINS THE DATA MATRIX OF THE LINEAR CONSTRAINTS.
C   B(MMAX) :  CONTAINS THE CONSTANT DATA OF THE LINEAR CONSTRAINTS.
C   XL(N),XU(N): CONTAIN THE LOWER AND UPPER BOUNDS FOR THE VARIABLES.
C   X(N) :     ON RETURN, X CONTAINS THE OPTIMAL SOLUTION VECTOR.
C   U(MNN) :   ON RETURN, U CONTAINS THE LAGRANGE MULTIPLIERS. THE FIRST
C              M POSITIONS ARE RESERVED FOR THE MULTIPLIERS OF THE M
C              LINEAR CONSTRAINTS AND THE SUBSEQUENT ONES FOR THE 
C              MULTIPLIERS OF THE LOWER AND UPPER BOUNDS. ON SUCCESSFUL
C              TERMINATION, ALL VALUES OF U WITH RESPECT TO INEQUALITIES 
C              AND BOUNDS SHOULD BE GREATER OR EQUAL TO ZERO.
C   IOUT :     INTEGER INDICATING THE DESIRED OUTPUT UNIT NUMBER, I.E.
C              ALL WRITE-STATEMENTS START WITH 'WRITE(IOUT,... '.
C   IFAIL :    SHOWS THE TERMINATION REASON.
C      IFAIL = 0 :   SUCCESSFUL RETURN.
C      IFAIL = 1 :   TOO MANY ITERATIONS (MORE THAN 40*(N+M)).
C      IFAIL = 2 :   ACCURACY INSUFFICIENT TO SATISFY CONVERGENCE
C                    CRITERION.
C      IFAIL = 5 :   LENGTH OF A WORKING ARRAY IS TOO SHORT.
C      IFAIL > 10 :  THE CONSTRAINTS ARE INCONSISTENT.
C   IPRINT :   OUTPUT CONTROL.
C      IPRINT = 0 :  NO OUTPUT OF QL0001.
C      IPRINT > 0 :  BRIEF OUTPUT IN ERROR CASES.
C   WAR(LWAR) : REAL WORKING ARRAY. THE LENGTH LWAR SHOULD BE GRATER THAN
C               3*NMAX*NMAX/2 + 10*NMAX + 2*MMAX.
C   IWAR(LIWAR): INTEGER WORKING ARRAY. THE LENGTH LIWAR SHOULD BE AT
C              LEAST N.
C              IF IWAR(1)=1 INITIALLY, THEN THE CHOLESKY DECOMPOSITION
C              WHICH IS REQUIRED BY THE DUAL ALGORITHM TO GET THE FIRST
C              UNCONSTRAINED MINIMUM OF THE OBJECTIVE FUNCTION, IS
C              PERFORMED INTERNALLY. OTHERWISE, I.E. IF IWAR(1)=0, THEN
C              IT IS ASSUMED THAT THE USER PROVIDES THE INITIAL FAC-
C              TORIZATION BY HIMSELF AND STORES IT IN THE UPPER TRIAN-
C              GULAR PART OF THE ARRAY C.
C
C   A NAMED COMMON-BLOCK  /CMACHE/EPS   MUST BE PROVIDED BY THE USER,
C   WHERE EPS DEFINES A GUESS FOR THE UNDERLYING MACHINE PRECISION.
C
C
C   AUTHOR (C): K. SCHITTKOWSKI,
C               MATHEMATISCHES INSTITUT,
C               UNIVERSITAET BAYREUTH,
C               95440 BAYREUTH,
C               GERMANY, F.R.
C
C
C   VERSION:    1.5  (JUNE, 1991)
C
C
C*********************************************************************
C
C
      INTEGER NMAX,MMAX,N,MNN,LWAR,LIWAR
      DIMENSION C(NMAX,N),D(N),A(MMAX,N),B(MMAX),
     1      XL(N),XU(N),X(N),U(MNN),WAR(LWAR),IWAR(LIWAR)
      DOUBLE PRECISION C,D,A,B,X,XL,XU,U,WAR,DIAG,ZERO,
     1      EPS,QPEPS,TEN
      INTEGER M,ME,IOUT,IFAIL,IPRINT,IWAR,INW1,INW2,IN,J,LW,MN,I,
     1      IDIAG,INFO,NACT,MAXIT
      LOGICAL LQL
C
C     INTRINSIC FUNCTIONS:  DSQRT
C
      COMMON /CMACHE/EPS
C
C     CONSTANT DATA
C
      LQL=.FALSE.
      IF (IWAR(1).EQ.1) LQL=.TRUE.
      ZERO=0.0D+0
      TEN=1.D+1
      MAXIT=40*(M+N)
      QPEPS=EPS
      INW1=1
      INW2=INW1+MMAX
C
C     PREPARE PROBLEM DATA FOR EXECUTION
C
      IF (M.LE.0) GOTO 20
      IN=INW1
      DO 10 J=1,M
      WAR(IN)=-B(J)
   10 IN=IN+1
   20 LW=3*NMAX*NMAX/2 + 10*NMAX + M
      IF ((INW2+LW).GT.LWAR) GOTO 80
      IF (LIWAR.LT.N) GOTO 81
      IF (MNN.LT.M+N+N) GOTO 82
      MN=M+N
C
C     CALL OF QL0002
C
      CALL QL0002(N,M,ME,MMAX,MN,MNN,NMAX,LQL,A,WAR(INW1),
     1    D,C,XL,XU,X,NACT,IWAR,MAXIT,QPEPS,INFO,DIAG,
     2    WAR(INW2),LW)
C
C     TEST OF MATRIX CORRECTIONS
C
      IFAIL=0
      IF (INFO.EQ.1) GOTO 40
      IF (INFO.EQ.2) GOTO 90
      IDIAG=0
      IF ((DIAG.GT.ZERO).AND.(DIAG.LT.1000.0)) IDIAG=DIAG
      IF ((IPRINT.GT.0).AND.(IDIAG.GT.0))
     1   WRITE(IOUT,1000) IDIAG
      IF (INFO .LT. 0) GOTO  70
C
C     REORDER MULTIPLIER
C
      DO  50 J=1,MNN
   50 U(J)=ZERO
      IN=INW2-1
      IF (NACT.EQ.0) GOTO 30
      DO  60 I=1,NACT
      J=IWAR(I)
      U(J)=WAR(IN+I)
   60 CONTINUE
   30 CONTINUE
      RETURN
C
C     ERROR MESSAGES
C
   70 IFAIL=-INFO+10
      IF ((IPRINT.GT.0).AND.(NACT.GT.0))
     1     WRITE(IOUT,1100) -INFO,(IWAR(I),I=1,NACT)
      RETURN
   80 IFAIL=5
      IF (IPRINT .GT. 0) WRITE(IOUT,1200)
      RETURN
   81 IFAIL=5
      IF (IPRINT .GT. 0) WRITE(IOUT,1210)
      RETURN
   82 IFAIL=5
      IF (IPRINT .GT. 0) WRITE(IOUT,1220)
      RETURN
   40 IFAIL=1
      IF (IPRINT.GT.0) WRITE(IOUT,1300) MAXIT
      RETURN
   90 IFAIL=2
      IF (IPRINT.GT.0) WRITE(IOUT,1400)
      RETURN
C
C     FORMAT-INSTRUCTIONS
C
 1000 FORMAT(/8X,28H***QL: MATRIX G WAS ENLARGED,I3,
     1        20H-TIMES BY UNITMATRIX)
 1100 FORMAT(/8X,18H***QL: CONSTRAINT ,I5,
     1        19H NOT CONSISTENT TO ,/,(10X,10I5))
 1200 FORMAT(/8X,21H***QL: LWAR TOO SMALL)
 1210 FORMAT(/8X,22H***QL: LIWAR TOO SMALL)
 1220 FORMAT(/8X,20H***QL: MNN TOO SMALL)
 1300 FORMAT(/8X,37H***QL: TOO MANY ITERATIONS (MORE THAN,I6,1H))
 1400 FORMAT(/8X,50H***QL: ACCURACY INSUFFICIENT TO ATTAIN CONVERGENCE) 
      END
C
      SUBROUTINE QL0002(N,M,MEQ,MMAX,MN,MNN,NMAX,LQL,A,B,GRAD,G,
     1      XL,XU,X,NACT,IACT,MAXIT,VSMALL,INFO,DIAG,W,LW)
C
C**************************************************************************
C
C
C   THIS SUBROUTINE SOLVES THE QUADRATIC PROGRAMMING PROBLEM 
C
C       MINIMIZE      GRAD'*X  +  0.5 * X*G*X
C       SUBJECT TO    A(K)*X  =  B(K)   K=1,2,...,MEQ,
C                     A(K)*X >=  B(K)   K=MEQ+1,...,M,
C                     XL  <=  X  <=  XU
C
C   THE QUADRATIC PROGRAMMING METHOD PROCEEDS FROM AN INITIAL CHOLESKY-
C   DECOMPOSITION OF THE OBJECTIVE FUNCTION MATRIX, TO CALCULATE THE
C   UNIQUELY DETERMINED MINIMIZER OF THE UNCONSTRAINED PROBLEM. 
C   SUCCESSIVELY ALL VIOLATED CONSTRAINTS ARE ADDED TO A WORKING SET 
C   AND A MINIMIZER OF THE OBJECTIVE FUNCTION SUBJECT TO ALL CONSTRAINTS
C   IN THIS WORKING SET IS COMPUTED. IT IS POSSIBLE THAT CONSTRAINTS
C   HAVE TO LEAVE THE WORKING SET.
C
C
C   DESCRIPTION OF PARAMETERS:
C
C     N        : IS THE NUMBER OF VARIABLES.
C     M        : TOTAL NUMBER OF CONSTRAINTS.
C     MEQ      : NUMBER OF EQUALITY CONTRAINTS.
C     MMAX     : ROW DIMENSION OF A, DIMENSION OF B. MMAX MUST BE AT
C                LEAST ONE AND GREATER OR EQUAL TO M.
C     MN       : MUST BE EQUAL M + N.
C     MNN      : MUST BE EQUAL M + N + N.
C     NMAX     : ROW DIEMSION OF G. MUST BE AT LEAST N.
C     LQL      : DETERMINES INITIAL DECOMPOSITION.
C        LQL = .FALSE.  : THE UPPER TRIANGULAR PART OF THE MATRIX G
C                         CONTAINS INITIALLY THE CHOLESKY-FACTOR OF A SUITABLE
C                         DECOMPOSITION.
C        LQL = .TRUE.   : THE INITIAL CHOLESKY-FACTORISATION OF G IS TO BE
C                         PERFORMED BY THE ALGORITHM.
C     A(MMAX,NMAX) : A IS A MATRIX WHOSE COLUMNS ARE THE CONSTRAINTS NORMALS.
C     B(MMAX)  : CONTAINS THE RIGHT HAND SIDES OF THE CONSTRAINTS.
C     GRAD(N)  : CONTAINS THE OBJECTIVE FUNCTION VECTOR GRAD.
C     G(NMAX,N): CONTAINS THE SYMMETRIC OBJECTIVE FUNCTION MATRIX.
C     XL(N), XU(N): CONTAIN THE LOWER AND UPPER BOUNDS FOR X.
C     X(N)     : VECTOR OF VARIABLES.
C     NACT     : FINAL NUMBER OF ACTIVE CONSTRAINTS.
C     IACT(K) (K=1,2,...,NACT): INDICES OF THE FINAL ACTIVE CONSTRAINTS.
C     INFO     : REASON FOR THE RETURN FROM THE SUBROUTINE.
C         INFO = 0 : CALCULATION WAS TERMINATED SUCCESSFULLY.
C         INFO = 1 : MAXIMUM NUMBER OF ITERATIONS ATTAINED.
C         INFO = 2 : ACCURACY IS INSUFFICIENT TO MAINTAIN INCREASING
C                    FUNCTION VALUES.
C         INFO < 0 : THE CONSTRAINT WITH INDEX ABS(INFO) AND THE CON-
C                    STRAINTS WHOSE INDICES ARE IACT(K), K=1,2,...,NACT,
C                    ARE INCONSISTENT.
C     MAXIT    : MAXIMUM NUMBER OF ITERATIONS.
C     VSMALL   : REQUIRED ACCURACY TO BE ACHIEVED (E.G. IN THE ORDER OF THE 
C                MACHINE PRECISION FOR SMALL AND WELL-CONDITIONED PROBLEMS).
C     DIAG     : ON RETURN DIAG IS EQUAL TO THE MULTIPLE OF THE UNIT MATRIX
C                THAT WAS ADDED TO G TO ACHIEVE POSITIVE DEFINITENESS.
C     W(LW)    : THE ELEMENTS OF W(.) ARE USED FOR WORKING SPACE. THE LENGTH
C                OF W MUST NOT BE LESS THAN (1.5*NMAX*NMAX + 10*NMAX + M).
C                WHEN INFO = 0 ON RETURN, THE LAGRANGE MULTIPLIERS OF THE
C                FINAL ACTIVE CONSTRAINTS ARE HELD IN W(K), K=1,2,...,NACT.
C   THE VALUES OF N, M, MEQ, MMAX, MN, MNN AND NMAX AND THE ELEMENTS OF
C   A, B, GRAD AND G ARE NOT ALTERED.
C
C   THE FOLLOWING INTEGERS ARE USED TO PARTITION W:
C     THE FIRST N ELEMENTS OF W HOLD LAGRANGE MULTIPLIER ESTIMATES.
C     W(IWZ+I+(N-1)*J) HOLDS THE MATRIX ELEMENT Z(I,J).
C     W(IWR+I+0.5*J*(J-1)) HOLDS THE UPPER TRIANGULAR MATRIX
C       ELEMENT R(I,J). THE SUBSEQUENT N COMPONENTS OF W MAY BE
C       TREATED AS AN EXTRA COLUMN OF R(.,.).
C     W(IWW-N+I) (I=1,2,...,N) ARE USED FOR TEMPORARY STORAGE.
C     W(IWW+I) (I=1,2,...,N) ARE USED FOR TEMPORARY STORAGE.
C     W(IWD+I) (I=1,2,...,N) HOLDS G(I,I) DURING THE CALCULATION.
C     W(IWX+I) (I=1,2,...,N) HOLDS VARIABLES THAT WILL BE USED TO
C       TEST THAT THE ITERATIONS INCREASE THE OBJECTIVE FUNCTION.
C     W(IWA+K) (K=1,2,...,M) USUALLY HOLDS THE RECIPROCAL OF THE
C       LENGTH OF THE K-TH CONSTRAINT, BUT ITS SIGN INDICATES
C       WHETHER THE CONSTRAINT IS ACTIVE.
C
C   
C   AUTHOR:    K. SCHITTKOWSKI,
C              MATHEMATISCHES INSTITUT,
C              UNIVERSITAET BAYREUTH,
C              8580 BAYREUTH,
C              GERMANY, F.R.
C
C   AUTHOR OF ORIGINAL VERSION:
C              M.J.D. POWELL, DAMTP,
C              UNIVERSITY OF CAMBRIDGE, SILVER STREET
C              CAMBRIDGE,
C              ENGLAND
C
C
C   REFERENCE: M.J.D. POWELL: ZQPCVX, A FORTRAN SUBROUTINE FOR CONVEX
C              PROGRAMMING, REPORT DAMTP/1983/NA17, UNIVERSITY OF
C              CAMBRIDGE, ENGLAND, 1983.
C
C
C   VERSION :  2.0 (MARCH, 1987)
C
C
C*************************************************************************
C
      INTEGER MMAX,NMAX,N,LW,NFLAG,IWWN
      DIMENSION A(MMAX,N),B(MMAX),GRAD(N),G(NMAX,N),X(N),IACT(N),
     1      W(LW),XL(N),XU(N)
      INTEGER M,MEQ,MN,MNN,NACT,IACT,INFO,MAXIT
      DOUBLE PRECISION CVMAX,DIAG,DIAGR,FDIFF,FDIFFA,GA,GB,PARINC,PARNEW
     1      ,RATIO,RES,STEP,SUM,SUMX,SUMY,SUMA,SUMB,SUMC,TEMP,TEMPA,
     2       VSMALL,XMAG,XMAGR,ZERO,ONE,TWO,ONHA,VFACT
      DOUBLE PRECISION A,B,G,GRAD,W,X,XL,XU
C
C   INTRINSIC FUNCTIONS:   DMAX1,DSQRT,DABS,DMIN1
C
      INTEGER IWZ,IWR,IWW,IWD,IWA,IFINC,KFINC,K,I,IA,ID,II,IR,IRA,
     1     IRB,J,NM,IZ,IZA,ITERC,ITREF,JFINC,IFLAG,IWS,IS,K1,IW,KK,IP,
     2     IPP,IL,IU,JU,KFLAG,LFLAG,JFLAG,KDROP,NU,MFLAG,KNEXT,IX,IWX,
     3     IWY,IY,JL
      LOGICAL LQL,LOWER
C
C   INITIAL ADDRESSES
C
      IWZ=NMAX
      IWR=IWZ+NMAX*NMAX
      IWW=IWR+(NMAX*(NMAX+3))/2
      IWD=IWW+NMAX
      IWX=IWD+NMAX
      IWA=IWX+NMAX
C
C     SET SOME CONSTANTS.
C
      ZERO=0.D+0
      ONE=1.D+0
      TWO=2.D+0
      ONHA=1.5D+0
      VFACT=1.D+0
C
C     SET SOME PARAMETERS.
C     NUMBER LESS THAN VSMALL ARE ASSUMED TO BE NEGLIGIBLE.
C     THE MULTIPLE OF I THAT IS ADDED TO G IS AT MOST DIAGR TIMES
C       THE LEAST MULTIPLE OF I THAT GIVES POSITIVE DEFINITENESS.
C     X IS RE-INITIALISED IF ITS MAGNITUDE IS REDUCED BY THE
C       FACTOR XMAGR.
C     A CHECK IS MADE FOR AN INCREASE IN F EVERY IFINC ITERATIONS,
C       AFTER KFINC ITERATIONS ARE COMPLETED.
C
      DIAGR=TWO
      DIAG=ZERO
      XMAGR=1.0D-2
      IFINC=3
      KFINC=MAX0(10,N)
C
C     FIND THE RECIPROCALS OF THE LENGTHS OF THE CONSTRAINT NORMALS.
C     RETURN IF A CONSTRAINT IS INFEASIBLE DUE TO A ZERO NORMAL.
C
      NACT=0
      IF (M .LE. 0) GOTO 45
      DO 40 K=1,M
      SUM=ZERO
      DO 10 I=1,N
   10 SUM=SUM+A(K,I)**2
      IF (SUM .GT. ZERO) GOTO 20
      IF (B(K) .EQ. ZERO) GOTO 30
      INFO=-K
      IF (K .LE. MEQ) GOTO 730
      IF (B(K)) 30,30,730
   20 SUM=ONE/DSQRT(SUM)
   30 IA=IWA+K
   40 W(IA)=SUM
   45 DO 50 K=1,N
      IA=IWA+M+K
   50 W(IA)=ONE
C
C     IF NECESSARY INCREASE THE DIAGONAL ELEMENTS OF G.
C
      IF (.NOT. LQL) GOTO 165
      DO 60 I=1,N
      ID=IWD+I
      W(ID)=G(I,I)
      DIAG=DMAX1(DIAG,VSMALL-W(ID))
      IF (I .EQ. N) GOTO 60
      II=I+1
      DO 55 J=II,N
      GA=-DMIN1(W(ID),G(J,J))
      GB=DABS(W(ID)-G(J,J))+DABS(G(I,J))
      IF (GB .GT. ZERO) GA=GA+G(I,J)**2/GB
   55 DIAG=DMAX1(DIAG,GA)
   60 CONTINUE
      IF (DIAG .LE. ZERO) GOTO 90
   70 DIAG=DIAGR*DIAG
      DO 80 I=1,N
      ID=IWD+I
   80 G(I,I)=DIAG+W(ID)
C
C     FORM THE CHOLESKY FACTORISATION OF G. THE TRANSPOSE
C     OF THE FACTOR WILL BE PLACED IN THE R-PARTITION OF W.
C
   90 IR=IWR
      DO 130 J=1,N
      IRA=IWR
      IRB=IR+1
      DO 120 I=1,J
      TEMP=G(I,J)
      IF (I .EQ. 1) GOTO 110
      DO 100 K=IRB,IR
      IRA=IRA+1
  100 TEMP=TEMP-W(K)*W(IRA)
  110 IR=IR+1
      IRA=IRA+1
      IF (I .LT. J) W(IR)=TEMP/W(IRA)
  120 CONTINUE
      IF (TEMP .LT. VSMALL) GOTO 140
  130 W(IR)=DSQRT(TEMP)
      GOTO 170
C
C     INCREASE FURTHER THE DIAGONAL ELEMENT OF G.
C
  140 W(J)=ONE
      SUMX=ONE
      K=J
  150 SUM=ZERO
      IRA=IR-1
      DO 160 I=K,J
      SUM=SUM-W(IRA)*W(I)
  160 IRA=IRA+I
      IR=IR-K
      K=K-1
      W(K)=SUM/W(IR)
      SUMX=SUMX+W(K)**2
      IF (K .GE. 2) GOTO 150
      DIAG=DIAG+VSMALL-TEMP/SUMX
      GOTO 70
C
C     STORE THE CHOLESKY FACTORISATION IN THE R-PARTITION
C     OF W.
C
  165 IR=IWR
      DO 166 I=1,N
      DO 166 J=1,I
      IR=IR+1
  166 W(IR)=G(J,I)
C
C     SET Z THE INVERSE OF THE MATRIX IN R.
C
  170 NM=N-1
      DO 220 I=1,N
      IZ=IWZ+I
      IF (I .EQ. 1) GOTO 190
      DO 180 J=2,I
      W(IZ)=ZERO
  180 IZ=IZ+N
  190 IR=IWR+(I+I*I)/2
      W(IZ)=ONE/W(IR)
      IF (I .EQ. N) GOTO 220
      IZA=IZ
      DO 210 J=I,NM
      IR=IR+I
      SUM=ZERO
      DO 200 K=IZA,IZ,N
      SUM=SUM+W(K)*W(IR)
  200 IR=IR+1
      IZ=IZ+N
  210 W(IZ)=-SUM/W(IR)
  220 CONTINUE
C
C     SET THE INITIAL VALUES OF SOME VARIABLES.
C     ITERC COUNTS THE NUMBER OF ITERATIONS.
C     ITREF IS SET TO ONE WHEN ITERATIVE REFINEMENT IS REQUIRED.
C     JFINC INDICATES WHEN TO TEST FOR AN INCREASE IN F.
C
      ITERC=1
      ITREF=0
      JFINC=-KFINC
C
C     SET X TO ZERO AND SET THE CORRESPONDING RESIDUALS OF THE
C     KUHN-TUCKER CONDITIONS.
C
  230 IFLAG=1
      IWS=IWW-N
      DO 240 I=1,N
      X(I)=ZERO
      IW=IWW+I
      W(IW)=GRAD(I)
      IF (I .GT. NACT) GOTO 240
      W(I)=ZERO
      IS=IWS+I
      K=IACT(I)
      IF (K .LE. M) GOTO 235
      IF (K .GT. MN) GOTO 234
      K1=K-M
      W(IS)=XL(K1)
      GOTO 240
  234 K1=K-MN
      W(IS)=-XU(K1)
      GOTO 240
  235 W(IS)=B(K)
  240 CONTINUE
      XMAG=ZERO
      VFACT=1.D+0
      IF (NACT) 340,340,280
C
C     SET THE RESIDUALS OF THE KUHN-TUCKER CONDITIONS FOR GENERAL X.
C
  250 IFLAG=2
      IWS=IWW-N
      DO 260 I=1,N
      IW=IWW+I
      W(IW)=GRAD(I)
      IF (LQL) GOTO 259
      ID=IWD+I
      W(ID)=ZERO
      DO 251 J=I,N
  251 W(ID)=W(ID)+G(I,J)*X(J)
      DO 252 J=1,I
      ID=IWD+J
  252 W(IW)=W(IW)+G(J,I)*W(ID)
      GOTO 260
  259 DO 261 J=1,N
  261 W(IW)=W(IW)+G(I,J)*X(J)
  260 CONTINUE
      IF (NACT .EQ. 0) GOTO 340
      DO 270 K=1,NACT
      KK=IACT(K)
      IS=IWS+K
      IF (KK .GT. M) GOTO 265
      W(IS)=B(KK)
      DO 264 I=1,N
      IW=IWW+I
      W(IW)=W(IW)-W(K)*A(KK,I)
  264 W(IS)=W(IS)-X(I)*A(KK,I)
      GOTO 270
  265 IF (KK .GT. MN) GOTO 266
      K1=KK-M
      IW=IWW+K1
      W(IW)=W(IW)-W(K)
      W(IS)=XL(K1)-X(K1)
      GOTO 270
  266 K1=KK-MN
      IW=IWW+K1
      W(IW)=W(IW)+W(K)
      W(IS)=-XU(K1)+X(K1)
  270 CONTINUE
C
C     PRE-MULTIPLY THE VECTOR IN THE S-PARTITION OF W BY THE
C     INVERS OF R TRANSPOSE.
C
  280 IR=IWR
      IP=IWW+1
      IPP=IWW+N
      IL=IWS+1
      IU=IWS+NACT
      DO 310 I=IL,IU
      SUM=ZERO
      IF (I .EQ. IL) GOTO 300
      JU=I-1
      DO 290 J=IL,JU
      IR=IR+1
  290 SUM=SUM+W(IR)*W(J)
  300 IR=IR+1
  310 W(I)=(W(I)-SUM)/W(IR)
C
C     SHIFT X TO SATISFY THE ACTIVE CONSTRAINTS AND MAKE THE
C     CORRESPONDING CHANGE TO THE GRADIENT RESIDUALS.
C
      DO 330 I=1,N
      IZ=IWZ+I
      SUM=ZERO
      DO 320 J=IL,IU
      SUM=SUM+W(J)*W(IZ)
  320 IZ=IZ+N
      X(I)=X(I)+SUM
      IF (LQL) GOTO 329
      ID=IWD+I
      W(ID)=ZERO
      DO 321 J=I,N
  321 W(ID)=W(ID)+G(I,J)*SUM
      IW=IWW+I
      DO 322 J=1,I
      ID=IWD+J
  322 W(IW)=W(IW)+G(J,I)*W(ID)
      GOTO 330
  329 DO 331 J=1,N
      IW=IWW+J
  331 W(IW)=W(IW)+SUM*G(I,J)
  330 CONTINUE
C
C     FORM THE SCALAR PRODUCT OF THE CURRENT GRADIENT RESIDUALS
C     WITH EACH COLUMN OF Z.
C
  340 KFLAG=1
      GOTO 930
  350 IF (NACT .EQ. N) GOTO 380
C
C     SHIFT X SO THAT IT SATISFIES THE REMAINING KUHN-TUCKER
C     CONDITIONS.
C
      IL=IWS+NACT+1
      IZA=IWZ+NACT*N
      DO 370 I=1,N
      SUM=ZERO
      IZ=IZA+I
      DO 360 J=IL,IWW
      SUM=SUM+W(IZ)*W(J)
  360 IZ=IZ+N
  370 X(I)=X(I)-SUM
      INFO=0
      IF (NACT .EQ. 0) GOTO 410
C
C     UPDATE THE LAGRANGE MULTIPLIERS.
C
  380 LFLAG=3
      GOTO 740
  390 DO 400 K=1,NACT
      IW=IWW+K
  400 W(K)=W(K)+W(IW)
C
C     REVISE THE VALUES OF XMAG.
C     BRANCH IF ITERATIVE REFINEMENT IS REQUIRED.
C
  410 JFLAG=1
      GOTO 910
  420 IF (IFLAG .EQ. ITREF) GOTO 250
C
C     DELETE A CONSTRAINT IF A LAGRANGE MULTIPLIER OF AN
C     INEQUALITY CONSTRAINT IS NEGATIVE.
C
      KDROP=0
      GOTO 440
  430 KDROP=KDROP+1
      IF (W(KDROP) .GE. ZERO) GOTO 440
      IF (IACT(KDROP) .LE. MEQ) GOTO 440
      NU=NACT
      MFLAG=1
      GOTO 800
  440 IF (KDROP .LT. NACT) GOTO 430
C
C     SEEK THE GREATEAST NORMALISED CONSTRAINT VIOLATION, DISREGARDING
C     ANY THAT MAY BE DUE TO COMPUTER ROUNDING ERRORS.
C
  450 CVMAX=ZERO
      IF (M .LE. 0) GOTO 481
      DO 480 K=1,M
      IA=IWA+K
      IF (W(IA) .LE. ZERO) GOTO 480
      SUM=-B(K)
      DO 460 I=1,N
  460 SUM=SUM+X(I)*A(K,I)
      SUMX=-SUM*W(IA)
      IF (K .LE. MEQ) SUMX=DABS(SUMX)
      IF (SUMX .LE. CVMAX) GOTO 480
      TEMP=DABS(B(K))
      DO 470 I=1,N
  470 TEMP=TEMP+DABS(X(I)*A(K,I))
      TEMPA=TEMP+DABS(SUM)
      IF (TEMPA .LE. TEMP) GOTO 480
      TEMP=TEMP+ONHA*DABS(SUM)
      IF (TEMP .LE. TEMPA) GOTO 480
      CVMAX=SUMX
      RES=SUM
      KNEXT=K
  480 CONTINUE
  481 DO 485 K=1,N
      LOWER=.TRUE.
      IA=IWA+M+K
      IF (W(IA) .LE. ZERO) GOTO 485
      SUM=XL(K)-X(K)
      IF (SUM) 482,485,483
  482 SUM=X(K)-XU(K)
      LOWER=.FALSE.
  483 IF (SUM .LE. CVMAX) GOTO 485
      CVMAX=SUM
      RES=-SUM
      KNEXT=K+M
      IF (LOWER) GOTO 485
      KNEXT=K+MN
  485 CONTINUE
C
C     TEST FOR CONVERGENCE
C
      INFO=0
      IF (CVMAX .LE. VSMALL) GOTO 700
C
C     RETURN IF, DUE TO ROUNDING ERRORS, THE ACTUAL CHANGE IN
C     X MAY NOT INCREASE THE OBJECTIVE FUNCTION
C
      JFINC=JFINC+1
      IF (JFINC .EQ. 0) GOTO 510
      IF (JFINC .NE. IFINC) GOTO 530
      FDIFF=ZERO
      FDIFFA=ZERO
      DO 500 I=1,N
      SUM=TWO*GRAD(I)
      SUMX=DABS(SUM)
      IF (LQL) GOTO 489
      ID=IWD+I
      W(ID)=ZERO
      DO 486 J=I,N
      IX=IWX+J
  486 W(ID)=W(ID)+G(I,J)*(W(IX)+X(J))
      DO 487 J=1,I
      ID=IWD+J
      TEMP=G(J,I)*W(ID)
      SUM=SUM+TEMP
  487 SUMX=SUMX+DABS(TEMP)
      GOTO 495
  489 DO 490 J=1,N
      IX=IWX+J
      TEMP=G(I,J)*(W(IX)+X(J))
      SUM=SUM+TEMP
  490 SUMX=SUMX+DABS(TEMP)
  495 IX=IWX+I
      FDIFF=FDIFF+SUM*(X(I)-W(IX))
  500 FDIFFA=FDIFFA+SUMX*DABS(X(I)-W(IX))
      INFO=2
      SUM=FDIFFA+FDIFF
      IF (SUM .LE. FDIFFA) GOTO 700
      TEMP=FDIFFA+ONHA*FDIFF
      IF (TEMP .LE. SUM) GOTO 700
      JFINC=0
      INFO=0
  510 DO 520 I=1,N
      IX=IWX+I
  520 W(IX)=X(I)
C
C     FORM THE SCALAR PRODUCT OF THE NEW CONSTRAINT NORMAL WITH EACH
C     COLUMN OF Z. PARNEW WILL BECOME THE LAGRANGE MULTIPLIER OF
C     THE NEW CONSTRAINT.
C
  530 ITERC=ITERC+1
      IF (ITERC.LE.MAXIT) GOTO 531
      INFO=1
      GOTO 710
  531 CONTINUE
      IWS=IWR+(NACT+NACT*NACT)/2
      IF (KNEXT .GT. M) GOTO 541
      DO 540 I=1,N
      IW=IWW+I
  540 W(IW)=A(KNEXT,I)
      GOTO 549
  541 DO 542 I=1,N
      IW=IWW+I
  542 W(IW)=ZERO
      K1=KNEXT-M
      IF (K1 .GT. N) GOTO 545
      IW=IWW+K1
      W(IW)=ONE
      IZ=IWZ+K1
      DO 543 I=1,N
      IS=IWS+I
      W(IS)=W(IZ)
  543 IZ=IZ+N
      GOTO 550
  545 K1=KNEXT-MN
      IW=IWW+K1
      W(IW)=-ONE
      IZ=IWZ+K1
      DO 546 I=1,N
      IS=IWS+I
      W(IS)=-W(IZ)
  546 IZ=IZ+N
      GOTO 550
  549 KFLAG=2
      GOTO 930
  550 PARNEW=ZERO
C
C     APPLY GIVENS ROTATIONS TO MAKE THE LAST (N-NACT-2) SCALAR
C     PRODUCTS EQUAL TO ZERO.
C
      IF (NACT .EQ. N) GOTO 570
      NU=N
      NFLAG=1
      GOTO 860
C
C     BRANCH IF THERE IS NO NEED TO DELETE A CONSTRAINT.
C
  560 IS=IWS+NACT
      IF (NACT .EQ. 0) GOTO 640
      SUMA=ZERO
      SUMB=ZERO
      SUMC=ZERO
      IZ=IWZ+NACT*N
      DO 563 I=1,N
      IZ=IZ+1
      IW=IWW+I
      SUMA=SUMA+W(IW)*W(IZ)
      SUMB=SUMB+DABS(W(IW)*W(IZ))
  563 SUMC=SUMC+W(IZ)**2
      TEMP=SUMB+.1D+0*DABS(SUMA)
      TEMPA=SUMB+.2D+0*DABS(SUMA)
      IF (TEMP .LE. SUMB) GOTO 570
      IF (TEMPA .LE. TEMP) GOTO 570
      IF (SUMB .GT. VSMALL) GOTO 5
      GOTO 570
    5 SUMC=DSQRT(SUMC)
      IA=IWA+KNEXT
      IF (KNEXT .LE. M) SUMC=SUMC/W(IA)
      TEMP=SUMC+.1D+0*DABS(SUMA)
      TEMPA=SUMC+.2D+0*DABS(SUMA)
      IF (TEMP .LE. SUMC) GOTO 567
      IF (TEMPA .LE. TEMP) GOTO 567
      GOTO 640
C
C     CALCULATE THE MULTIPLIERS FOR THE NEW CONSTRAINT NORMAL
C     EXPRESSED IN TERMS OF THE ACTIVE CONSTRAINT NORMALS.
C     THEN WORK OUT WHICH CONTRAINT TO DROP.
C
  567 LFLAG=4
      GOTO 740
  570 LFLAG=1
      GOTO 740
C
C     COMPLETE THE TEST FOR LINEARLY DEPENDENT CONSTRAINTS.
C
  571 IF (KNEXT .GT. M) GOTO 574
      DO 573 I=1,N
      SUMA=A(KNEXT,I)
      SUMB=DABS(SUMA)
      IF (NACT.EQ.0) GOTO 581
      DO 572 K=1,NACT
      KK=IACT(K)
      IF (KK.LE.M) GOTO 568
      KK=KK-M
      TEMP=ZERO
      IF (KK.EQ.I) TEMP=W(IWW+KK)
      KK=KK-N
      IF (KK.EQ.I) TEMP=-W(IWW+KK)
      GOTO 569
  568 CONTINUE
      IW=IWW+K
      TEMP=W(IW)*A(KK,I)
  569 CONTINUE
      SUMA=SUMA-TEMP
  572 SUMB=SUMB+DABS(TEMP)
  581 IF (SUMA .LE. VSMALL) GOTO 573
      TEMP=SUMB+.1D+0*DABS(SUMA)
      TEMPA=SUMB+.2D+0*DABS(SUMA)
      IF (TEMP .LE. SUMB) GOTO 573
      IF (TEMPA .LE. TEMP) GOTO 573
      GOTO 630
  573 CONTINUE
      LFLAG=1
      GOTO 775
  574 K1=KNEXT-M
      IF (K1 .GT. N) K1=K1-N
      DO 578 I=1,N
      SUMA=ZERO
      IF (I .NE. K1) GOTO 575
      SUMA=ONE
      IF (KNEXT .GT. MN) SUMA=-ONE
  575 SUMB=DABS(SUMA)
      IF (NACT.EQ.0) GOTO 582
      DO 577 K=1,NACT
      KK=IACT(K)
      IF (KK .LE. M) GOTO 579
      KK=KK-M
      TEMP=ZERO
      IF (KK.EQ.I) TEMP=W(IWW+KK)
      KK=KK-N
      IF (KK.EQ.I) TEMP=-W(IWW+KK)
      GOTO 576
  579 IW=IWW+K
      TEMP=W(IW)*A(KK,I)
  576 SUMA=SUMA-TEMP
  577 SUMB=SUMB+DABS(TEMP)
  582 TEMP=SUMB+.1D+0*DABS(SUMA)
      TEMPA=SUMB+.2D+0*DABS(SUMA)
      IF (TEMP .LE. SUMB) GOTO 578
      IF (TEMPA .LE. TEMP) GOTO 578
      GOTO 630
  578 CONTINUE
      LFLAG=1
      GOTO 775
C
C     BRANCH IF THE CONTRAINTS ARE INCONSISTENT.
C
  580 INFO=-KNEXT
      IF (KDROP .EQ. 0) GOTO 700
      PARINC=RATIO
      PARNEW=PARINC
C
C     REVISE THE LAGRANGE MULTIPLIERS OF THE ACTIVE CONSTRAINTS.
C
  590 IF (NACT.EQ.0) GOTO 601
      DO 600 K=1,NACT
      IW=IWW+K
      W(K)=W(K)-PARINC*W(IW)
      IF (IACT(K) .GT. MEQ) W(K)=DMAX1(ZERO,W(K))
  600 CONTINUE
  601 IF (KDROP .EQ. 0) GOTO 680
C
C     DELETE THE CONSTRAINT TO BE DROPPED.
C     SHIFT THE VECTOR OF SCALAR PRODUCTS.
C     THEN, IF APPROPRIATE, MAKE ONE MORE SCALAR PRODUCT ZERO.
C
      NU=NACT+1
      MFLAG=2
      GOTO 800
  610 IWS=IWS-NACT-1
      NU=MIN0(N,NU)
      DO 620 I=1,NU
      IS=IWS+I
      J=IS+NACT
  620 W(IS)=W(J+1)
      NFLAG=2
      GOTO 860
C
C     CALCULATE THE STEP TO THE VIOLATED CONSTRAINT.
C
  630 IS=IWS+NACT
  640 SUMY=W(IS+1)
      STEP=-RES/SUMY
      PARINC=STEP/SUMY
      IF (NACT .EQ. 0) GOTO 660
C
C     CALCULATE THE CHANGES TO THE LAGRANGE MULTIPLIERS, AND REDUCE
C     THE STEP ALONG THE NEW SEARCH DIRECTION IF NECESSARY.
C
      LFLAG=2
      GOTO 740
  650 IF (KDROP .EQ. 0) GOTO 660
      TEMP=ONE-RATIO/PARINC
      IF (TEMP .LE. ZERO) KDROP=0
      IF (KDROP .EQ. 0) GOTO 660
      STEP=RATIO*SUMY
      PARINC=RATIO
      RES=TEMP*RES
C
C     UPDATE X AND THE LAGRANGE MULTIPIERS.
C     DROP A CONSTRAINT IF THE FULL STEP IS NOT TAKEN.
C
  660 IWY=IWZ+NACT*N
      DO 670 I=1,N
      IY=IWY+I
  670 X(I)=X(I)+STEP*W(IY)
      PARNEW=PARNEW+PARINC
      IF (NACT .GE. 1) GOTO 590
C
C     ADD THE NEW CONSTRAINT TO THE ACTIVE SET.
C
  680 NACT=NACT+1
      W(NACT)=PARNEW
      IACT(NACT)=KNEXT
      IA=IWA+KNEXT
      IF (KNEXT .GT. MN) IA=IA-N
      W(IA)=-W(IA)
C
C     ESTIMATE THE MAGNITUDE OF X. THEN BEGIN A NEW ITERATION,
C     RE-INITILISING X IF THIS MAGNITUDE IS SMALL.
C
      JFLAG=2
      GOTO 910
  690 IF (SUM .LT. (XMAGR*XMAG)) GOTO 230
      IF (ITREF) 450,450,250
C
C     INITIATE ITERATIVE REFINEMENT IF IT HAS NOT YET BEEN USED,
C     OR RETURN AFTER RESTORING THE DIAGONAL ELEMENTS OF G.
C
  700 IF (ITERC .EQ. 0) GOTO 710
      ITREF=ITREF+1
      JFINC=-1
      IF (ITREF .EQ. 1) GOTO 250
  710 IF (.NOT. LQL) RETURN
      DO 720 I=1,N
      ID=IWD+I
  720 G(I,I)=W(ID)
  730 RETURN
C
C
C     THE REMAINING INSTRUCTIONS ARE USED AS SUBROUTINES.
C
C
C********************************************************************
C
C
C     CALCULATE THE LAGRANGE MULTIPLIERS BY PRE-MULTIPLYING THE
C     VECTOR IN THE S-PARTITION OF W BY THE INVERSE OF R.
C
  740 IR=IWR+(NACT+NACT*NACT)/2
      I=NACT
      SUM=ZERO
      GOTO 770
  750 IRA=IR-1
      SUM=ZERO
      IF (NACT.EQ.0) GOTO 761
      DO 760 J=I,NACT
      IW=IWW+J
      SUM=SUM+W(IRA)*W(IW)
  760 IRA=IRA+J
  761 IR=IR-I
      I=I-1
  770 IW=IWW+I
      IS=IWS+I
      W(IW)=(W(IS)-SUM)/W(IR)
      IF (I .GT. 1) GOTO 750
      IF (LFLAG .EQ. 3) GOTO 390
      IF (LFLAG .EQ. 4) GOTO 571
C
C     CALCULATE THE NEXT CONSTRAINT TO DROP.
C
  775 IP=IWW+1
      IPP=IWW+NACT
      KDROP=0
      IF (NACT.EQ.0) GOTO 791
      DO 790 K=1,NACT
      IF (IACT(K) .LE. MEQ) GOTO 790
      IW=IWW+K
      IF ((RES*W(IW)) .GE. ZERO) GOTO 790
      TEMP=W(K)/W(IW)
      IF (KDROP .EQ. 0) GOTO 780
      IF (DABS(TEMP) .GE. DABS(RATIO)) GOTO 790
  780 KDROP=K
      RATIO=TEMP
  790 CONTINUE
  791 GOTO (580,650), LFLAG
C
C
C********************************************************************
C
C
C     DROP THE CONSTRAINT IN POSITION KDROP IN THE ACTIVE SET.
C
  800 IA=IWA+IACT(KDROP)
      IF (IACT(KDROP) .GT. MN) IA=IA-N
      W(IA)=-W(IA)
      IF (KDROP .EQ. NACT) GOTO 850
C
C     SET SOME INDICES AND CALCULATE THE ELEMENTS OF THE NEXT
C     GIVENS ROTATION.
C
      IZ=IWZ+KDROP*N
      IR=IWR+(KDROP+KDROP*KDROP)/2
  810 IRA=IR
      IR=IR+KDROP+1
      TEMP=DMAX1(DABS(W(IR-1)),DABS(W(IR)))
      SUM=TEMP*DSQRT((W(IR-1)/TEMP)**2+(W(IR)/TEMP)**2)
      GA=W(IR-1)/SUM
      GB=W(IR)/SUM
C
C     EXCHANGE THE COLUMNS OF R.
C
      DO 820 I=1,KDROP
      IRA=IRA+1
      J=IRA-KDROP
      TEMP=W(IRA)
      W(IRA)=W(J)
  820 W(J)=TEMP
      W(IR)=ZERO
C
C     APPLY THE ROTATION TO THE ROWS OF R.
C
      W(J)=SUM
      KDROP=KDROP+1
      DO 830 I=KDROP,NU
      TEMP=GA*W(IRA)+GB*W(IRA+1)
      W(IRA+1)=GA*W(IRA+1)-GB*W(IRA)
      W(IRA)=TEMP
  830 IRA=IRA+I
C
C     APPLY THE ROTATION TO THE COLUMNS OF Z.
C
      DO 840 I=1,N
      IZ=IZ+1
      J=IZ-N
      TEMP=GA*W(J)+GB*W(IZ)
      W(IZ)=GA*W(IZ)-GB*W(J)
  840 W(J)=TEMP
C
C     REVISE IACT AND THE LAGRANGE MULTIPLIERS.
C
      IACT(KDROP-1)=IACT(KDROP)
      W(KDROP-1)=W(KDROP)
      IF (KDROP .LT. NACT) GOTO 810
  850 NACT=NACT-1
      GOTO (250,610), MFLAG
C
C
C********************************************************************
C
C
C     APPLY GIVENS ROTATION TO REDUCE SOME OF THE SCALAR
C     PRODUCTS IN THE S-PARTITION OF W TO ZERO.
C
  860 IZ=IWZ+NU*N
  870 IZ=IZ-N
  880 IS=IWS+NU
      NU=NU-1
      IF (NU .EQ. NACT) GOTO 900
      IF (W(IS) .EQ. ZERO) GOTO 870
      TEMP=DMAX1(DABS(W(IS-1)),DABS(W(IS)))
      SUM=TEMP*DSQRT((W(IS-1)/TEMP)**2+(W(IS)/TEMP)**2)
      GA=W(IS-1)/SUM
      GB=W(IS)/SUM
      W(IS-1)=SUM
      DO 890 I=1,N
      K=IZ+N
      TEMP=GA*W(IZ)+GB*W(K)
      W(K)=GA*W(K)-GB*W(IZ)
      W(IZ)=TEMP
  890 IZ=IZ-1
      GOTO 880
  900 GOTO (560,630), NFLAG
C
C
C********************************************************************
C
C
C     CALCULATE THE MAGNITUDE OF X AN REVISE XMAG.
C
  910 SUM=ZERO
      DO 920 I=1,N
      SUM=SUM+DABS(X(I))*VFACT*(DABS(GRAD(I))+DABS(G(I,I)*X(I)))
      IF (LQL) GOTO 920
      IF (SUM .LT. 1.D-30) GOTO 920
      VFACT=1.D-10*VFACT
      SUM=1.D-10*SUM
      XMAG=1.D-10*XMAG
  920 CONTINUE
  925 XMAG=DMAX1(XMAG,SUM)
      GOTO (420,690), JFLAG
C
C
C********************************************************************
C
C
C     PRE-MULTIPLY THE VECTOR IN THE W-PARTITION OF W BY Z TRANSPOSE.
C
  930 JL=IWW+1
      IZ=IWZ
      DO 940 I=1,N
      IS=IWS+I
      W(IS)=ZERO
      IWWN=IWW+N
      DO 940 J=JL,IWWN
      IZ=IZ+1
  940 W(IS)=W(IS)+W(IZ)*W(J)
      GOTO (350,550), KFLAG
      RETURN
      END

