[ 10%] Built target Pita
[ 10%] Built target Feti
[ 10%] Built target Timers
[ 11%] Built target Parser
[ 14%] Built target Driver
[ 14%] Building CXX object Element.d/CMakeFiles/Elem.dir/MpcElement.d/PointPointDistanceConstraint.C.o
/lustre/home/mpotts/FEM/./Element.d/MpcElement.d/PointPointDistanceConstraint.h: In member function 'Scalar PointPointDistanceConstraintFunction<Scalar>::operator()(const Eigen::Matrix<_Scalar, 3, 1, 0, 3, 1>&, Scalar) const [with Scalar = Eigen::AutoDiffScalar<Eigen::Matrix<Sacado::RadVec::ADvar<double>, 3, 1, 0, 3, 1> >]':
/lustre/home/mpotts/FEM/./Element.d/MpcElement.d/ConstraintFunction.h:60:   instantiated from 'int SpatialView<_Scalar, ConstraintFunctionTemplate>::operator()(const Eigen::Matrix<T, SpatialView<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime, 1, (ColMajor | (((SpatialView<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime == 1) && (1 != 1)) ? RowMajor : (((1 == 1) && (SpatialView<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime != 1)) ? ColMajor :  ColMajor))), SpatialView<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime, 1>&, Eigen::Matrix<T, SpatialView<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime, 1, (ColMajor | (((SpatialView<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime == 1) && (1 != 1)) ? RowMajor : (((1 == 1) && (SpatialView<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime != 1)) ? ColMajor :  ColMajor))), SpatialView<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime, 1>&) const [with T = Eigen::AutoDiffScalar<Eigen::Matrix<Sacado::RadVec::ADvar<double>, 3, 1, 0, 3, 1> >, _Scalar = Sacado::RadVec::ADvar<double>, ConstraintFunctionTemplate = PointPointDistanceConstraintFunction]'
/lustre/home/mpotts/FEM/./Element.d/MpcElement.d/ConstraintFunction.h:67:   instantiated from 'int SpatialView<_Scalar, ConstraintFunctionTemplate>::operator()(const Eigen::Matrix<T, SpatialView<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime, 1, (ColMajor | (((SpatialView<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime == 1) && (1 != 1)) ? RowMajor : (((1 == 1) && (SpatialView<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime != 1)) ? ColMajor :  ColMajor))), SpatialView<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime, 1>&, Eigen::Matrix<T, SpatialView<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime, 1, (ColMajor | (((SpatialView<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime == 1) && (1 != 1)) ? RowMajor : (((1 == 1) && (SpatialView<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime != 1)) ? ColMajor :  ColMajor))), SpatialView<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime, 1>*) const [with T = Eigen::AutoDiffScalar<Eigen::Matrix<Sacado::RadVec::ADvar<double>, 3, 1, 0, 3, 1> >, _Scalar = Sacado::RadVec::ADvar<double>, ConstraintFunctionTemplate = PointPointDistanceConstraintFunction]'
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h:84:   instantiated from 'void Eigen::AutoDiffJacobian<Functor>::operator()(const typename Functor::InputType&, typename Functor::ValueType*, typename Functor::JacobianType*) const [with Functor = SpatialView<Sacado::RadVec::ADvar<double>, PointPointDistanceConstraintFunction>]'
/lustre/home/mpotts/FEM/./Element.d/MpcElement.d/ConstraintFunction.h:114:   instantiated from 'int SpatialJacobian<_Scalar, ConstraintFunctionTemplate>::operator()(const Eigen::Matrix<T, SpatialJacobian<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime, 1, (ColMajor | (((SpatialJacobian<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime == 1) && (1 != 1)) ? RowMajor : (((1 == 1) && (SpatialJacobian<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime != 1)) ? ColMajor :  ColMajor))), SpatialJacobian<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime, 1>&, Eigen::Matrix<T, SpatialJacobian<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime, 1, (ColMajor | (((SpatialJacobian<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime == 1) && (1 != 1)) ? RowMajor : (((1 == 1) && (SpatialJacobian<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime != 1)) ? ColMajor :  ColMajor))), SpatialJacobian<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime, 1>&) const [with T = Sacado::RadVec::ADvar<double>, _Scalar = double, ConstraintFunctionTemplate = PointPointDistanceConstraintFunction]'
/lustre/home/mpotts/FEM/./Element.d/MpcElement.d/ConstraintFunction.h:384:   instantiated from 'int SacadoReverseJacobian<Functor>::operator()(const Eigen::Matrix<T, Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime, 1, (ColMajor | (((Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime == 1) && (1 != 1)) ? RowMajor : (((1 == 1) && (Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime != 1)) ? ColMajor :  ColMajor))), Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime, 1>&, Eigen::Matrix<T, Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime, Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime, (ColMajor | (((Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime == 1) && (Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime != 1)) ? RowMajor : (((Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime == 1) && (Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime != 1)) ? ColMajor :  ColMajor))), Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime, Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime>&) const [with T = double, Functor = SpatialJacobian<double, PointPointDistanceConstraintFunction>]'
/lustre/home/mpotts/FEM/./Element.d/MpcElement.d/ConstraintFunctionElement.C:137:   instantiated from 'void ConstraintFunctionElement<ConstraintFunctionTemplate>::getHessian(GeomState&, CoordSet&, FullSquareMatrix&, double) [with ConstraintFunctionTemplate = PointPointDistanceConstraintFunction]'
/lustre/home/mpotts/FEM/Element.d/MpcElement.d/PointPointDistanceConstraint.C:29:   instantiated from here
/lustre/home/mpotts/FEM/./Element.d/MpcElement.d/PointPointDistanceConstraint.h:43: error: ambiguous overload for 'operator*' in '((const PointPointDistanceConstraintFunction<Eigen::AutoDiffScalar<Eigen::Matrix<Sacado::RadVec::ADvar<double>, 3, 1, 0, 3, 1> > >*)this)->PointPointDistanceConstraintFunction<Eigen::AutoDiffScalar<Eigen::Matrix<Sacado::RadVec::ADvar<double>, 3, 1, 0, 3, 1> > >::C * t'
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note: candidates are: const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> >&>&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<Sacado::RadVec::ADvar<double> >, const Eigen::Matrix<Sacado::RadVec::ADvar<double>, 1, 1, 0, 1, 1> > > Eigen::operator*(const Sacado::RadVec::ADvar<double>&, const Eigen::AutoDiffScalar<Eigen::Matrix<Sacado::RadVec::ADvar<double>, 1, 1, 0, 1, 1> >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::Matrix<double, 1, 1, 0, 1, 1> >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<Sacado::RadVec::ADvar<double> >, const Eigen::Matrix<Sacado::RadVec::ADvar<double>, 3, 1, 0, 3, 1> > > Eigen::operator*(const Sacado::RadVec::ADvar<double>&, const Eigen::AutoDiffScalar<Eigen::Matrix<Sacado::RadVec::ADvar<double>, 3, 1, 0, 3, 1> >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::Matrix<double, 3, 1, 0, 3, 1> >&)
/lustre/home/mpotts/FEM/./Element.d/MpcElement.d/PointPointDistanceConstraint.h:43: error: ambiguous overload for 'operator*' in '((const PointPointDistanceConstraintFunction<Eigen::AutoDiffScalar<Eigen::Matrix<Sacado::RadVec::ADvar<double>, 3, 1, 0, 3, 1> > >*)this)->PointPointDistanceConstraintFunction<Eigen::AutoDiffScalar<Eigen::Matrix<Sacado::RadVec::ADvar<double>, 3, 1, 0, 3, 1> > >::omega * t'
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note: candidates are: const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> >&>&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<Sacado::RadVec::ADvar<double> >, const Eigen::Matrix<Sacado::RadVec::ADvar<double>, 1, 1, 0, 1, 1> > > Eigen::operator*(const Sacado::RadVec::ADvar<double>&, const Eigen::AutoDiffScalar<Eigen::Matrix<Sacado::RadVec::ADvar<double>, 1, 1, 0, 1, 1> >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::Matrix<double, 1, 1, 0, 1, 1> >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<Sacado::RadVec::ADvar<double> >, const Eigen::Matrix<Sacado::RadVec::ADvar<double>, 3, 1, 0, 3, 1> > > Eigen::operator*(const Sacado::RadVec::ADvar<double>&, const Eigen::AutoDiffScalar<Eigen::Matrix<Sacado::RadVec::ADvar<double>, 3, 1, 0, 3, 1> >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::Matrix<double, 3, 1, 0, 3, 1> >&)
/lustre/home/mpotts/FEM/./Element.d/MpcElement.d/PointPointDistanceConstraint.h: In member function 'Scalar PointPointDistanceConstraintFunction<Scalar>::operator()(const Eigen::Matrix<_Scalar, 3, 1, 0, 3, 1>&, Scalar) const [with Scalar = Eigen::AutoDiffScalar<Eigen::Matrix<Sacado::RadVec::ADvar<double>, 1, 1, 0, 1, 1> >]':
/lustre/home/mpotts/FEM/./Element.d/MpcElement.d/ConstraintFunction.h:167:   instantiated from 'int TemporalView<_Scalar, ConstraintFunctionTemplate>::operator()(const Eigen::Matrix<T, TemporalView<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime, 1, (ColMajor | (((TemporalView<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime == 1) && (1 != 1)) ? RowMajor : (((1 == 1) && (TemporalView<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime != 1)) ? ColMajor :  ColMajor))), TemporalView<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime, 1>&, Eigen::Matrix<T, TemporalView<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime, 1, (ColMajor | (((TemporalView<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime == 1) && (1 != 1)) ? RowMajor : (((1 == 1) && (TemporalView<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime != 1)) ? ColMajor :  ColMajor))), TemporalView<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime, 1>&) const [with T = Eigen::AutoDiffScalar<Eigen::Matrix<Sacado::RadVec::ADvar<double>, 1, 1, 0, 1, 1> >, _Scalar = Sacado::RadVec::ADvar<double>, ConstraintFunctionTemplate = PointPointDistanceConstraintFunction]'
/lustre/home/mpotts/FEM/./Element.d/MpcElement.d/ConstraintFunction.h:174:   instantiated from 'int TemporalView<_Scalar, ConstraintFunctionTemplate>::operator()(const Eigen::Matrix<T, TemporalView<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime, 1, (ColMajor | (((TemporalView<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime == 1) && (1 != 1)) ? RowMajor : (((1 == 1) && (TemporalView<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime != 1)) ? ColMajor :  ColMajor))), TemporalView<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime, 1>&, Eigen::Matrix<T, TemporalView<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime, 1, (ColMajor | (((TemporalView<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime == 1) && (1 != 1)) ? RowMajor : (((1 == 1) && (TemporalView<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime != 1)) ? ColMajor :  ColMajor))), TemporalView<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime, 1>*) const [with T = Eigen::AutoDiffScalar<Eigen::Matrix<Sacado::RadVec::ADvar<double>, 1, 1, 0, 1, 1> >, _Scalar = Sacado::RadVec::ADvar<double>, ConstraintFunctionTemplate = PointPointDistanceConstraintFunction]'
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h:84:   instantiated from 'void Eigen::AutoDiffJacobian<Functor>::operator()(const typename Functor::InputType&, typename Functor::ValueType*, typename Functor::JacobianType*) const [with Functor = TemporalView<Sacado::RadVec::ADvar<double>, PointPointDistanceConstraintFunction>]'
/lustre/home/mpotts/FEM/./Element.d/MpcElement.d/ConstraintFunction.h:222:   instantiated from 'int TemporalJacobian<_Scalar, ConstraintFunctionTemplate>::operator()(const Eigen::Matrix<T, TemporalJacobian<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime, 1, (ColMajor | (((TemporalJacobian<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime == 1) && (1 != 1)) ? RowMajor : (((1 == 1) && (TemporalJacobian<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime != 1)) ? ColMajor :  ColMajor))), TemporalJacobian<_Scalar, ConstraintFunctionTemplate>::InputsAtCompileTime, 1>&, Eigen::Matrix<T, TemporalJacobian<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime, 1, (ColMajor | (((TemporalJacobian<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime == 1) && (1 != 1)) ? RowMajor : (((1 == 1) && (TemporalJacobian<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime != 1)) ? ColMajor :  ColMajor))), TemporalJacobian<_Scalar, ConstraintFunctionTemplate>::ValuesAtCompileTime, 1>&) const [with T = Sacado::RadVec::ADvar<double>, _Scalar = double, ConstraintFunctionTemplate = PointPointDistanceConstraintFunction]'
/lustre/home/mpotts/FEM/./Element.d/MpcElement.d/ConstraintFunction.h:384:   instantiated from 'int SacadoReverseJacobian<Functor>::operator()(const Eigen::Matrix<T, Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime, 1, (ColMajor | (((Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime == 1) && (1 != 1)) ? RowMajor : (((1 == 1) && (Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime != 1)) ? ColMajor :  ColMajor))), Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime, 1>&, Eigen::Matrix<T, Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime, Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime, (ColMajor | (((Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime == 1) && (Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime != 1)) ? RowMajor : (((Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime == 1) && (Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime != 1)) ? ColMajor :  ColMajor))), Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime, Functor::#'typename_type' not supported by pp_cxx_unqualified_id#::SizeAtCompileTime>&) const [with T = double, Functor = TemporalJacobian<double, PointPointDistanceConstraintFunction>]'
/lustre/home/mpotts/FEM/./Element.d/MpcElement.d/ConstraintFunctionElement.C:251:   instantiated from 'double ConstraintFunctionElement<ConstraintFunctionTemplate>::getAccelerationConstraintRhs(GeomState*, CoordSet&, double) [with ConstraintFunctionTemplate = PointPointDistanceConstraintFunction]'
/lustre/home/mpotts/FEM/Element.d/MpcElement.d/PointPointDistanceConstraint.C:29:   instantiated from here
/lustre/home/mpotts/FEM/./Element.d/MpcElement.d/PointPointDistanceConstraint.h:43: error: ambiguous overload for 'operator*' in '((const PointPointDistanceConstraintFunction<Eigen::AutoDiffScalar<Eigen::Matrix<Sacado::RadVec::ADvar<double>, 1, 1, 0, 1, 1> > >*)this)->PointPointDistanceConstraintFunction<Eigen::AutoDiffScalar<Eigen::Matrix<Sacado::RadVec::ADvar<double>, 1, 1, 0, 1, 1> > >::C * t'
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note: candidates are: const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >&>&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<Sacado::RadVec::ADvar<double> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<Sacado::RadVec::ADvar<double> >, const Eigen::Matrix<Sacado::RadVec::ADvar<double>, 3, 1, 0, 3, 1> > > > Eigen::operator*(const Sacado::RadVec::ADvar<double>&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<Sacado::RadVec::ADvar<double> >, const Eigen::Matrix<Sacado::RadVec::ADvar<double>, 3, 1, 0, 3, 1> > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> >&>&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<Sacado::RadVec::ADvar<double> >, const Eigen::Matrix<Sacado::RadVec::ADvar<double>, 1, 1, 0, 1, 1> > > Eigen::operator*(const Sacado::RadVec::ADvar<double>&, const Eigen::AutoDiffScalar<Eigen::Matrix<Sacado::RadVec::ADvar<double>, 1, 1, 0, 1, 1> >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::Matrix<double, 1, 1, 0, 1, 1> >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<Sacado::RadVec::ADvar<double> >, const Eigen::Matrix<Sacado::RadVec::ADvar<double>, 3, 1, 0, 3, 1> > > Eigen::operator*(const Sacado::RadVec::ADvar<double>&, const Eigen::AutoDiffScalar<Eigen::Matrix<Sacado::RadVec::ADvar<double>, 3, 1, 0, 3, 1> >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::Matrix<double, 3, 1, 0, 3, 1> >&)
/lustre/home/mpotts/FEM/./Element.d/MpcElement.d/PointPointDistanceConstraint.h:43: error: ambiguous overload for 'operator*' in '((const PointPointDistanceConstraintFunction<Eigen::AutoDiffScalar<Eigen::Matrix<Sacado::RadVec::ADvar<double>, 1, 1, 0, 1, 1> > >*)this)->PointPointDistanceConstraintFunction<Eigen::AutoDiffScalar<Eigen::Matrix<Sacado::RadVec::ADvar<double>, 1, 1, 0, 1, 1> > >::omega * t'
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note: candidates are: const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> >&>&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<Sacado::RadVec::ADvar<double> >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<Sacado::RadVec::ADvar<double> >, const Eigen::Matrix<Sacado::RadVec::ADvar<double>, 3, 1, 0, 3, 1> > > > Eigen::operator*(const Sacado::RadVec::ADvar<double>&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<Sacado::RadVec::ADvar<double> >, const Eigen::Matrix<Sacado::RadVec::ADvar<double>, 3, 1, 0, 3, 1> > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseBinaryOp<Eigen::internal::scalar_difference_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseBinaryOp<Eigen::internal::scalar_sum_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> >&>&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_opposite_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<Sacado::RadVec::ADvar<double> >, const Eigen::Matrix<Sacado::RadVec::ADvar<double>, 1, 1, 0, 1, 1> > > Eigen::operator*(const Sacado::RadVec::ADvar<double>&, const Eigen::AutoDiffScalar<Eigen::Matrix<Sacado::RadVec::ADvar<double>, 1, 1, 0, 1, 1> >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 1, 1, 0, 1, 1> > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::Matrix<double, 1, 1, 0, 1, 1> >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<Sacado::RadVec::ADvar<double> >, const Eigen::Matrix<Sacado::RadVec::ADvar<double>, 3, 1, 0, 3, 1> > > Eigen::operator*(const Sacado::RadVec::ADvar<double>&, const Eigen::AutoDiffScalar<Eigen::Matrix<Sacado::RadVec::ADvar<double>, 3, 1, 0, 3, 1> >&)
/lustre/home/avery/code/eigen/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h:272: note:                 const Eigen::AutoDiffScalar<Eigen::CwiseUnaryOp<Eigen::internal::scalar_multiple_op<double>, const Eigen::Matrix<double, 3, 1, 0, 3, 1> > > Eigen::operator*(const double&, const Eigen::AutoDiffScalar<Eigen::Matrix<double, 3, 1, 0, 3, 1> >&)
make[2]: *** [Element.d/CMakeFiles/Elem.dir/MpcElement.d/PointPointDistanceConstraint.C.o] Error 1
make[1]: *** [Element.d/CMakeFiles/Elem.dir/all] Error 2
make: *** [all] Error 2
